{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Portafolio Ibero Puebla","text":"<p>\u00a1Bienvenido a mi portafolio de evidencias! Aqu\u00ed encontrar\u00e1s tareas, proyectos y recursos de Mecatr\u00f3nica.</p>"},{"location":"#sobre-mi","title":"Sobre m\u00ed","text":"<p>Soy Carlos Ernesto Camacho Gonz\u00e1lez, estudiante de Mecatr\u00f3nica en Ibero Puebla.  </p>"},{"location":"#contenido","title":"Contenido","text":"<ul> <li>Tareas \u2014 comparaciones y pr\u00e1cticas de GPIO, l\u00f3gica y m\u00e1scaras.  </li> <li>Proyecto de ingenier\u00eda V \u2014 objetivo, alcance, avances y entregables.  </li> </ul>"},{"location":"#contacto","title":"Contacto","text":"<ul> <li>Correo: 198168@iberopuebla.mx </li> <li>GitHub: https://github.com/CarlosCamachog</li> </ul>"},{"location":"comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p>[x] Hecho</p> </li> <li>[ ] Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"},{"location":"Proyecto%20de%20ingenieria%20IV/","title":"Index","text":""},{"location":"Proyecto%20de%20ingenieria%20IV/digramadegantt/","title":"Diagrama de Gantt \u2014 Citizen Quack","text":"<p>Periodo: Sep\u2013Nov 2025 \u00b7 Herramienta: TeamGantt</p> <p>A continuaci\u00f3n se muestra el diagrama de Gantt del proyecto Citizen Quack. Si el ancho de tu pantalla es peque\u00f1o, toca la imagen para verla completa.</p> <p></p> Lista de tareas (resumen)  - Definir objetivos y par\u00e1metros a medir (pH, turbidez, temperatura, etc.). - Hacer lista de materiales (sensores, microcontrolador, bater\u00edas). - Adquirir sensores y componentes; montar en protoboard; verificar en agua. - Identificar necesidad de recubrimiento (resina/silic\u00f3n) y hacer diagrama el\u00e9ctrico. - Prueba de flotabilidad con el pato; montar sensores en el flotador. - Integrar microcontrolador y bater\u00eda; leer datos de sensores; registrar datos."},{"location":"Proyecto%20de%20ingenieria%20IV/ejemplo/","title":"Citizen Quack \u2014 Soluci\u00f3n de calidad del agua","text":"<p>Citizen Quack con sensores de calidad del agua y env\u00edo LoRa a un panel de datos.</p>"},{"location":"Proyecto%20de%20ingenieria%20IV/ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): Carlos Ernesto Camacho Gonz\u00e1lez, Danna Paola Garc\u00eda Sanchez, Sebastian Rodas Apango </li> <li>Curso / Asignatura: Proyecto de Ingenier\u00eda IV </li> <li>Fecha: 01/09/2025  </li> <li>Descripci\u00f3n breve: Se propone un nodo flotante con forma de pato que mide pH, temperatura, conductividad, etc en cuerpos de agua. Los datos se env\u00edan por LoRa a una estaci\u00f3n base y se visualizan en un panel de datos.</li> </ul> <p>no se</p>"},{"location":"Proyecto%20de%20ingenieria%20IV/ejemplo/#2-problema-y-motivacion","title":"2) Problema y motivaci\u00f3n","text":"<ul> <li>Monitoreo de calidad del agua intermitente o manual.  </li> </ul>"},{"location":"Proyecto%20de%20ingenieria%20IV/ejemplo/#3-boceto","title":"3) Boceto","text":""},{"location":"Proyecto%20de%20ingenieria%20IV/ejemplo/#7-pdf-de-syllabus","title":"7) PDF de Syllabus","text":"<p>Descargar el PDF</p>"},{"location":"Tareas/","title":"\ud83d\uddc2\ufe0f Sistemas embebidos I \u2014 Portada","text":"<p>Bienvenido a la secci\u00f3n de Sistemas embebidos I del portafolio. Aqu\u00ed recopilo pr\u00e1cticas con Raspberry Pi Pico 2.</p>"},{"location":"Tareas/#indice","title":"\u00cdndice","text":"<ul> <li> <p>Tarea 1 \u2014 Comparaci\u00f3n y ranking de microcontroladores   Tabla comparativa (ESP32, STM32F103, RP2040, ATmega328P) y ranking con recomendaciones.</p> </li> <li> <p>Tarea 2 \u2014 Outputs b\u00e1sicos con l\u00f3gica y m\u00e1scaras Contador binario (4 bits), barrido de LEDs y secuencia Gray usando m\u00e1scaras.</p> </li> <li> <p>Tarea 3 \u2014 Inputs con l\u00f3gica y m\u00e1scaras AND / OR / XOR con botones pull-up y selector c\u00edclico con antirrebote por flanco.</p> </li> </ul>"},{"location":"Tareas/Examen/","title":"\ud83c\udfae Reto \u2014 Sim\u00f3n Dice (4 colores) \u00b7 Raspberry Pi Pico 2","text":"<p>Juego de memoria con 4 LEDs y 4 botones en Raspberry Pi Pico 2 (RP2350), con secuencia aleatoria que crece por ronda, tiempo l\u00edmite por entrada y fallos por bot\u00f3n incorrecto, por dos pulsaciones simult\u00e1neas o por timeout.  </p>"},{"location":"Tareas/Examen/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Sim\u00f3n Dice (4 colores) \u2013 Pico 2  </li> <li>Autor: Carlos Ernesto Camacho Gonz\u00e1lez  </li> <li>Curso / Asignatura: Sistemas Embebidos  </li> <li>Fecha: 22/09/2025  </li> <li>Descripci\u00f3n breve: Implementaci\u00f3n de un juego \u201cSim\u00f3n Dice\u201d con reproducci\u00f3n de secuencia, entrada del jugador con TL = 5 s + longitud de la ronda, y antirrebote por flanco. Se usa el timer de sistema con ALARM0/ALARM1 para marcar la reproducci\u00f3n y el timeout de entrada, y GPIO IRQ para leer botones sin polling.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n la l\u00f3gica sin bucles de polling: usa interrupciones del timer y de GPIO para conseguir respuesta inmediata y timing preciso.</p>"},{"location":"Tareas/Examen/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Desarrollar un juego completo con interrupciones (timer + GPIO), antirrebote por flancos y manejo de estados.</li> <li>Espec\u00edficos:</li> <li>Reproducir la secuencia actual LED por LED con temporizaci\u00f3n fija.</li> <li>Aceptar la entrada del jugador bajo un tiempo l\u00edmite dependiente de la ronda.</li> <li>Detectar fallos por bot\u00f3n equivocado, doble pulsaci\u00f3n simult\u00e1nea o exceso de tiempo.</li> <li>Asegurar aleatoriedad de la secuencia en cada ejecuci\u00f3n.</li> </ul>"},{"location":"Tareas/Examen/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: </li> <li>GPIO como salidas (LED0..LED3) y entradas con pull-up (BTN0..BTN3).  </li> <li>Timer HW en modo \u00b5s con ALARM0 (reproducci\u00f3n) y ALARM1 (timeout).  </li> <li>IRQ de GPIO con antirrebote por flanco (30 ms).  </li> <li>Detecci\u00f3n de pulsaci\u00f3n m\u00faltiple (&gt;1 bot\u00f3n) como fallo.</li> <li>No incluye: </li> <li>Display de 7 segmentos (omitido).  </li> <li>Almacenamiento de puntaje en memoria o audio.</li> </ul>"},{"location":"Tareas/Examen/#4-requisitos","title":"4) Requisitos","text":"<p>Hardware - Raspberry Pi Pico 2 (RP2350). - 4 LEDs con resistencias de 220\u2013330 \u03a9 conectados a GPIO 0..3. - 4 botones tipo push conectados a GPIO 4..7 con pull-up interno (a GND al presionar). - Protoboard y cables.</p> <p>Software - Pico SDK configurado (RP2350). - CMake + Ninja o tu entorno preferido.</p> <p>Conocimientos previos - Interrupciones (timer y GPIO). - Manejo de m\u00e1scaras y GPIO. - Conceptos de debounce y deadline.</p>"},{"location":"Tareas/Examen/#5-reglas-del-juego-aplicadas","title":"5) Reglas del juego (aplicadas)","text":"<ul> <li>Inicio/Reset: al energizar, LEDs apagados; cualquier bot\u00f3n inicia la Ronda 1.  </li> <li>Reproducci\u00f3n: se muestra la secuencia actual (LED por LED) a 0.5 s por paso.  </li> <li>Entrada: el jugador repite la secuencia completa dentro de TL = 5 s + ronda.  </li> <li>Fallo (Game Over): </li> <li>Bot\u00f3n incorrecto en cualquier paso.  </li> <li>Dos o m\u00e1s botones presionados a la vez durante la fase de entrada.  </li> <li>Exceder TL (timeout).  </li> <li>Progresi\u00f3n: si acierta, ronda++, se a\u00f1ade 1 color aleatorio y se repite.  </li> <li>Fin: al fallar o al completar NMAX_RONDAS (configurada en el c\u00f3digo como 8).</li> </ul>"},{"location":"Tareas/Examen/#6-mapa-de-pines-y-conexion","title":"6) Mapa de pines y conexi\u00f3n","text":"Se\u00f1al GPIO Tipo Conexi\u00f3n recomendada LED0 0 OUT LED\u2192R(220\u2013330 \u03a9)\u2192GPIO 0; c\u00e1todo a GND LED1 1 OUT LED\u2192R\u2192GPIO 1; c\u00e1todo a GND LED2 2 OUT LED\u2192R\u2192GPIO 2; c\u00e1todo a GND LED3 3 OUT LED\u2192R\u2192GPIO 3; c\u00e1todo a GND BTN0 4 IN Bot\u00f3n a GND; habilita pull-up interno BTN1 5 IN Bot\u00f3n a GND; habilita pull-up interno BTN2 6 IN Bot\u00f3n a GND; habilita pull-up interno BTN3 7 IN Bot\u00f3n a GND; habilita pull-up interno <p>Con esta topolog\u00eda, el nivel activo es bajo (0) al presionar.</p>"},{"location":"Tareas/Examen/#7-conceptos-clave-rapido","title":"7) Conceptos clave (r\u00e1pido)","text":"<ul> <li>Debounce (antirrebote): Filtrado temporal (p. ej., 30 ms) para ignorar rebotes al cambiar de estado el bot\u00f3n. Aqu\u00ed se hace por flanco, validando solo transiciones 1\u21920 estables.  </li> <li>Deadline / Timeout (TL): L\u00edmite de tiempo para completar la entrada. Se programa con una alarma del timer: si llega y la tarea no se complet\u00f3, falla.  </li> <li>Edge IRQ: Interrupci\u00f3n por flanco (subida/bajada); evita polling y mejora la latencia.  </li> <li>Secuencia aleatoria: <code>rand()%4</code> con semilla desde <code>time_us_32()</code> desfasada.</li> </ul>"},{"location":"Tareas/Examen/#8-codigo-completo-c-pico-sdk","title":"8) C\u00f3digo completo (C \u00b7 Pico SDK)","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include \"pico/stdlib.h\"\n#include \"pico/time.h\"\n#include \"hardware/gpio.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n// LEDs y botones\n#define LED0 0\n#define LED1 1\n#define LED2 2\n#define LED3 3\n#define BTN0 4\n#define BTN1 5\n#define BTN2 6\n#define BTN3 7\n\n#define NMAX_RONDAS 8\n\n// Estados del juego\nvolatile bool START = false;\nvolatile bool START_SECUENCIA = false;\nvolatile bool START_ESPERA = false;\n\nstatic volatile uint8_t SECUENCIA[NMAX_RONDAS];\nstatic volatile uint8_t RONDA = 0;\nstatic volatile uint8_t RONDA_ACTUAL = 0;\nstatic volatile uint8_t CONTADOR = 0;\n\n// Alarmas\n#define ALARMA_SECUENCIA 0\n#define ALARMA_ESPERA    1\n#define ALARMA_SECUENCIA_IRQ timer_hardware_alarm_get_irq_num(timer_hw, ALARMA_SECUENCIA)\n#define ALARMA_ESPERA_IRQ    timer_hardware_alarm_get_irq_num(timer_hw, ALARMA_ESPERA)\n\nstatic volatile uint32_t NEXT_AS_US, NEXT_AE_US;\nstatic const uint32_t INTERVALO_AS_US = 500000u;  // 0.5 s (ritmo de reproducci\u00f3n)\nstatic const uint32_t BASE_AE_US      = 5000000u; // 5 s base del TL\n\n// Antirrebote por flanco\nstatic const uint32_t DEBOUNCE_US = 30000u; // 30 ms\nstatic volatile uint32_t LAST_EDGE_US[4] = {0,0,0,0};\nstatic volatile uint8_t  LAST_STATE[4]   = {1,1,1,1}; // 1 = suelto (pull-up), 0 = presionado\n\n// Prototipos\nstatic void GENERAR_ELEMENTO(void);\nstatic void BLINK_SECUENCIA(void);\nstatic void SISTEMA_DE_ESPERA(void);\nstatic void START_AS(void);\nstatic void STOP_AS(void);\nstatic void START_AE(void);\nstatic void STOP_AE(void);\nstatic void BTN_ISR(uint gpio, uint32_t events); // ISR de botones\nstatic inline uint8_t BOTONES_PRESIONADOS(void);\nstatic inline void GAME_OVER(void);\n\nint main(void) {\n    stdio_init_all();\n\n    // LEDs\n    for (uint8_t i = LED0; i &lt;= LED3; i++) {\n        gpio_init(i);\n        gpio_set_dir(i, GPIO_OUT);\n        gpio_put(i, 0);\n    }\n    // Botones (pull-up interno)\n    for (uint8_t i = BTN0; i &lt;= BTN3; i++) {\n        gpio_init(i);\n        gpio_set_dir(i, GPIO_IN);\n        gpio_pull_up(i);\n    }\n\n    // Semilla random\n    srand((time_us_32() * 7) ^ (time_us_32() &gt;&gt; 3));\n\n    // Timer HW\n    timer_hw-&gt;source = 0u;\n    hw_clear_bits(&amp;timer_hw-&gt;intr, (1u &lt;&lt; ALARMA_SECUENCIA) | (1u &lt;&lt; ALARMA_ESPERA));\n    irq_set_exclusive_handler(ALARMA_SECUENCIA_IRQ, BLINK_SECUENCIA);\n    irq_set_exclusive_handler(ALARMA_ESPERA_IRQ,    SISTEMA_DE_ESPERA);\n\n    // IRQ de botones: flancos de subida y bajada\n    gpio_set_irq_enabled_with_callback(BTN0, GPIO_IRQ_EDGE_FALL | GPIO_IRQ_EDGE_RISE, true, &amp;BTN_ISR);\n    gpio_set_irq_enabled(BTN1, GPIO_IRQ_EDGE_FALL | GPIO_IRQ_EDGE_RISE, true);\n    gpio_set_irq_enabled(BTN2, GPIO_IRQ_EDGE_FALL | GPIO_IRQ_EDGE_RISE, true);\n    gpio_set_irq_enabled(BTN3, GPIO_IRQ_EDGE_FALL | GPIO_IRQ_EDGE_RISE, true);\n\n    // Bucle ocioso (sin polling)\n    while (true) {\n        tight_loop_contents(); // o __wfi()\n    }\n}\n\n/*** Helpers ***/\nstatic void GENERAR_ELEMENTO(void){\n    if (RONDA &lt;= NMAX_RONDAS) SECUENCIA[RONDA - 1] = rand() % 4;\n}\n\nstatic inline void GAME_OVER(void){\n    for (uint8_t j = 0; j &lt; 4; j++) gpio_put(j, 0);\n    STOP_AE(); STOP_AS();\n    START = false;\n    START_ESPERA = false;\n    START_SECUENCIA = false;\n}\n\nstatic inline uint8_t BOTONES_PRESIONADOS(void){\n    // Cuenta cu\u00e1ntos est\u00e1n a nivel bajo (activo) en este instante\n    uint8_t c = 0;\n    c += (gpio_get(BTN0) == 0);\n    c += (gpio_get(BTN1) == 0);\n    c += (gpio_get(BTN2) == 0);\n    c += (gpio_get(BTN3) == 0);\n    return c;\n}\n\n/*** ISR secuencia (reproducci\u00f3n) ***/\nstatic void BLINK_SECUENCIA(void){\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARMA_SECUENCIA);\n    if (!START_SECUENCIA) { STOP_AS(); return; }\n\n    static bool ENCENDIDO = false;\n    if (RONDA == 0) { STOP_AS(); return; }\n\n    uint8_t led = SECUENCIA[CONTADOR];\n    if (!ENCENDIDO) {\n        gpio_put(led, 1);\n        ENCENDIDO = true;\n    } else {\n        gpio_put(led, 0);\n        ENCENDIDO = false;\n        CONTADOR++;\n    }\n\n    NEXT_AS_US += INTERVALO_AS_US;\n    timer_hw-&gt;alarm[ALARMA_SECUENCIA] = NEXT_AS_US;\n\n    if (CONTADOR &gt;= RONDA &amp;&amp; !ENCENDIDO) {\n        CONTADOR = 0;\n        START_SECUENCIA = false;\n        START_ESPERA = true;\n        STOP_AS();\n        START_AE(); // TL = 5 s + RONDA (segundos)\n    }\n}\n\n/*** ISR espera l\u00edmite (timeout de entrada) ***/\nstatic void SISTEMA_DE_ESPERA(void){\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARMA_ESPERA);\n    if (START_ESPERA) {\n        // Tiempo agotado =&gt; fallo\n        GAME_OVER();\n    }\n}\n\n/*** Alarmas ***/\nstatic void START_AS(void){\n    uint32_t now = timer_hw-&gt;timerawl;\n    NEXT_AS_US = now + INTERVALO_AS_US;\n    timer_hw-&gt;alarm[ALARMA_SECUENCIA] = NEXT_AS_US;\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARMA_SECUENCIA);\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARMA_SECUENCIA);\n    irq_set_enabled(ALARMA_SECUENCIA_IRQ, true);\n}\nstatic void STOP_AS(void){\n    hw_clear_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARMA_SECUENCIA);\n    irq_set_enabled(ALARMA_SECUENCIA_IRQ, false);\n}\nstatic void START_AE(void){\n    uint32_t now = timer_hw-&gt;timerawl;\n    NEXT_AE_US = now + BASE_AE_US + ((uint32_t)RONDA) * 1000000u; // TL = 5s + RONDA\n    timer_hw-&gt;alarm[ALARMA_ESPERA] = NEXT_AE_US;\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARMA_ESPERA);\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARMA_ESPERA);\n    irq_set_enabled(ALARMA_ESPERA_IRQ, true);\n}\nstatic void STOP_AE(void){\n    hw_clear_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARMA_ESPERA);\n    irq_set_enabled(ALARMA_ESPERA_IRQ, false);\n}\n\n/*** ISR de BOTONES (GPIO) con antirrebote por flanco\n     + detecci\u00f3n de pulsaci\u00f3n m\u00faltiple (fail) ***/\nstatic void BTN_ISR(uint gpio, uint32_t events) {\n    uint32_t now = time_us_32();\n    int i = (int)gpio - BTN0; // BTN0..BTN3 =&gt; 0..3\n    if (i &lt; 0 || i &gt; 3) return;\n\n    // Nivel actual (pull-up =&gt; 1 = suelto, 0 = presionado)\n    int level = gpio_get(gpio) ? 1 : 0;\n\n    // Flanco de subida: solo cierra ciclo (no hay l\u00f3gica de juego)\n    if (events &amp; GPIO_IRQ_EDGE_RISE) {\n        if ((now - LAST_EDGE_US[i]) &gt;= DEBOUNCE_US) {\n            LAST_STATE[i]   = 1;   // estable en alto (suelto)\n            LAST_EDGE_US[i] = now;\n        }\n        return;\n    }\n\n    // Flanco de bajada: validar debounce + transici\u00f3n 1-&gt;0 real\n    if (events &amp; GPIO_IRQ_EDGE_FALL) {\n        if ((now - LAST_EDGE_US[i]) &lt; DEBOUNCE_US) return;      // rebote temporal\n        if (!(LAST_STATE[i] == 1 &amp;&amp; level == 0)) return;        // no es 1-&gt;0 estable\n        LAST_STATE[i]   = 0;\n        LAST_EDGE_US[i] = now;\n\n        // --- REGLA NUEVA: si en fase de entrada hay &gt;1 bot\u00f3n presionado =&gt; fallo ---\n        if (START_ESPERA) {\n            if (BOTONES_PRESIONADOS() &gt; 1) {\n                GAME_OVER();\n                return;\n            }\n        }\n\n        // --- L\u00d3GICA DE JUEGO (id\u00e9ntica al dise\u00f1o original) ---\n        if (!START) {\n            // iniciar juego\n            START = true;\n            RONDA = 1;\n            RONDA_ACTUAL = 0;\n            CONTADOR = 0;\n            GENERAR_ELEMENTO();\n            START_SECUENCIA = true;\n            START_AS();\n        } else if (START_ESPERA) {\n            if ((uint8_t)i == SECUENCIA[RONDA_ACTUAL]) {\n                RONDA_ACTUAL++;\n                if (RONDA_ACTUAL &gt;= RONDA) {\n                    if (RONDA &gt;= NMAX_RONDAS) {\n                        // Gan\u00f3\n                        for (uint8_t j = 0; j &lt; 4; j++) gpio_put(j, 1);\n                        START = false;\n                        START_ESPERA = false;\n                        START_SECUENCIA = false;\n                        STOP_AS();\n                        STOP_AE();\n                    } else {\n                        // siguiente ronda\n                        RONDA_ACTUAL = 0;\n                        RONDA++;\n                        GENERAR_ELEMENTO();\n                        START_SECUENCIA = true;\n                        START_ESPERA = false;\n                        CONTADOR = 0;\n                        STOP_AE();\n                        START_AS();\n                    }\n                }\n            } else {\n                // error (bot\u00f3n incorrecto)\n                GAME_OVER();\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"Tareas/tarea1/","title":"\ud83d\udcd8 Tarea 1 \u2014 Comparaci\u00f3n y ranking de microcontroladores","text":"<p>Documento de comparaci\u00f3n y ranking de 4 MCUs.</p>"},{"location":"Tareas/tarea1/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Comparaci\u00f3n y ranking de microcontroladores  </li> <li>Autor: Carlos Ernesto Camacho Gonz\u00e1lez</li> <li>Curso / Asignatura: Sistemas Embebidos  </li> <li>Fecha: 27/08/2025  </li> <li>Descripci\u00f3n breve: Se comparan ESP32, STM32F103C8T6, RP2040 y ATmega328P en perif\u00e9ricos, memoria, ecosistema, costo y rendimiento para proponer un ranking de uso recomendado.</li> </ul> <p>Consejo</p> <p>Elige el MCU seg\u00fan el contexto: conectividad IoT, facilidad para aprender, costo o escalabilidad industrial.</p>"},{"location":"Tareas/tarea1/#2-objetivos","title":"2) Objetivos","text":"<ul> <li> <p>General: Identificar el microcontrolador m\u00e1s conveniente seg\u00fan requisitos t\u00edpicos de proyectos de mecatr\u00f3nica.</p> </li> <li> <p>Espec\u00edficos:</p> </li> <li>Comparar perif\u00e9ricos y conectividad integrada.</li> <li>Contrastar memoria, arquitectura y frecuencia de trabajo.</li> <li>Valorar el ecosistema (IDE/SDK, documentaci\u00f3n y comunidad).</li> <li>Considerar costo aproximado en MXN y facilidad de uso.</li> <li>Proponer un ranking justificado y casos de uso sugeridos.</li> </ul>"},{"location":"Tareas/tarea1/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: 4 MCUs representativos (ESP32, STM32F103C8T6, RP2040, ATmega328P) y su comparaci\u00f3n a nivel hoja de datos/experiencia general.  </li> <li>No incluye: Benchmarks el\u00e9ctricos finos (sleep, ruido anal\u00f3gico), pruebas RF, certificaciones ni costos de producci\u00f3n en volumen.</li> </ul>"},{"location":"Tareas/tarea1/#4-requisitos","title":"4) Requisitos","text":"<p>Software - Editor (VS Code) y navegador. - (Opcional) MkDocs + Material para publicar.</p> <p>Hardware (si se desea experimentar) - ESP32-DevKit, Blue Pill (STM32F103C8T6), Raspberry Pi Pico (RP2040), Arduino UNO (ATmega328P).</p> <p>Conocimientos previos - Lectura b\u00e1sica de datasheets y pinouts. - Perif\u00e9ricos: ADC, UART, SPI, I\u00b2C, PWM. - Flujo con IDE/SDK (Arduino IDE, ESP-IDF, Pico SDK, STM32CubeIDE).</p>"},{"location":"Tareas/tarea1/#5-microcontroladores-elegidos","title":"5) Microcontroladores elegidos","text":"<ul> <li>ESP32 (Espressif)  </li> <li>STM32F103C8T6 (STMicroelectronics)  </li> <li>RP2040 (Raspberry Pi Pico)  </li> <li>ATmega328P (Arduino UNO, Microchip)  </li> </ul>"},{"location":"Tareas/tarea1/#6-tabla-comparativa","title":"6) Tabla comparativa","text":"MCU + Marca Perif\u00e9ricos Memoria (Flash / RAM) Ecosistema Costo aprox. (MXN) Arquitectura Velocidad de trabajo ESP32 (Espressif) Wi-Fi, Bluetooth, ADC 12b, 2\u00d7DAC, UART, SPI, I\u00b2C, PWM, touch ~4 MB Flash (m\u00f3dulo), ~520 KB SRAM Arduino IDE o ESP-IDF, comunidad IoT 120\u2013250 Xtensa LX6 dual-core 32 bits 240 MHz STM32F103C8T6 (ST) ADC 12b, UART, CAN, I\u00b2C, SPI, timers 64 KB Flash, 20 KB SRAM STM32CubeIDE/HAL, uso industrial 100\u2013250 ARM Cortex-M3 32 bits 72 MHz RP2040 (Raspberry Pi) 2\u00d7ADC, UART, SPI, I\u00b2C, PWM, PIO programable 2 MB Flash, 264 KB SRAM SDK C/C++ y MicroPython, comunidad amplia 150\u2013200 ARM Cortex-M0+ dual-core 32 bits 133 MHz ATmega328P (Microchip) ADC 10b, UART, SPI, I\u00b2C, timers 32 KB Flash, 2 KB SRAM Arduino IDE, comunidad educativa enorme 200\u2013300 (Arduino UNO) AVR 8 bits 16 MHz <pre><code>note \"Precios\"\nCostos referenciales en MXN; var\u00edan por marca/placa, memoria y disponibilidad.\n</code></pre>"},{"location":"Tareas/tarea1/#7-criterios-usados-para-el-ranking","title":"7) Criterios usados para el ranking","text":"<ul> <li>Conectividad integrada (Wi-Fi/BLE) para IoT.  </li> <li>Ecosistema/soporte (IDE oficiales, SDKs, documentaci\u00f3n, comunidad).  </li> <li>Rendimiento (arquitectura, n\u00facleos y frecuencia).  </li> <li>Memoria disponible (Flash/RAM \u00fatiles).  </li> <li>Costo y facilidad de aprendizaje/puesta en marcha.</li> </ul>"},{"location":"Tareas/tarea1/#8-ranking-de-microcontroladores-con-justificacion","title":"8) Ranking de microcontroladores (con justificaci\u00f3n)","text":"<ol> <li> <p>ESP32    Mayor cantidad de perif\u00e9ricos y conectividad Wi-Fi/Bluetooth integrada, buen rendimiento y bajo costo. Ideal para IoT, prototipado r\u00e1pido y proyectos de mecatr\u00f3nica actuales.</p> </li> <li> <p>RP2040 (Raspberry Pi Pico)    Doble n\u00facleo, PIO muy flexible y comunidad enorme. No trae radio integrada, pero es vers\u00e1til y econ\u00f3mico para control, procesamiento ligero y aprendizaje.</p> </li> <li> <p>STM32F103C8T6 (Blue Pill)    Arquitectura ARM Cortex-M3 y presencia en industria. Excelente para aprender HAL/STM32CubeIDE. Curva de aprendizaje m\u00e1s alta que ESP32/Pico.</p> </li> <li> <p>ATmega328P (Arduino UNO)    Limitado en memoria/velocidad, pero con la comunidad educativa m\u00e1s grande y facil\u00edsimo para empezar. \u00datil en pr\u00e1cticas introductorias y proyectos simples.</p> </li> </ol>"},{"location":"Tareas/tarea1/#9-conclusiones-y-recomendaciones","title":"9) Conclusiones y recomendaciones","text":"<ul> <li>Si necesitas IoT con bajo costo y rapidez \u2192 ESP32.  </li> <li>Si quieres control flexible y aprender concurrente/PIO \u2192 RP2040.  </li> <li>Si el enfoque es industrial/ARM y HAL \u2192 STM32F103C8T6.  </li> <li>Para educaci\u00f3n b\u00e1sica y prototipos simples \u2192 ATmega328P.</li> </ul>"},{"location":"Tareas/tarea2/","title":"\ud83d\udcd8 Tarea 2 \u2014 Outputs b\u00e1sicos con l\u00f3gica y m\u00e1scaras","text":"<p>Tres pr\u00e1cticas con GPIO en Raspberry Pi Pico: contador binario, barrido de LEDs y secuencia en c\u00f3digo Gray.</p>"},{"location":"Tareas/tarea2/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Outputs b\u00e1sicos con l\u00f3gica y m\u00e1scaras  </li> <li>Autor: Carlos Ernesto Camacho Gonz\u00e1lez </li> <li>Curso / Asignatura: Sistemas Embebidos  </li> <li>Fecha: 27/08/2025  </li> <li>Descripci\u00f3n breve: Implementaci\u00f3n de patrones de salida con GPIO usando m\u00e1scaras: contador de 4 bits, barrido tipo \u201cping-pong\u201d y generaci\u00f3n de c\u00f3digo Gray.</li> </ul> <p>Consejo</p> <p>Usa m\u00e1scaras (<code>MASK</code>) para configurar y escribir varios pines a la vez: el c\u00f3digo queda m\u00e1s corto y r\u00e1pido.</p>"},{"location":"Tareas/tarea2/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Practicar el uso de m\u00e1scaras de bits para controlar m\u00faltiples GPIO y consolidar patrones de salida.</li> <li>Espec\u00edficos:</li> <li>Generar un contador binario de 4 bits.</li> <li>Implementar un barrido asc/desc de LEDs.</li> <li>Producir una secuencia Gray de 3 bits usando operaciones a nivel bit.</li> </ul>"},{"location":"Tareas/tarea2/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Configuraci\u00f3n de GPIO como salida, escritura en paralelo con <code>gpio_put_masked</code> / <code>gpio_set_mask</code> / <code>gpio_clr_mask</code>, y temporizaci\u00f3n con <code>sleep_ms</code>.</li> <li>No incluye: Interrupciones.</li> </ul>"},{"location":"Tareas/tarea2/#4-requisitos","title":"4) Requisitos","text":"<p>Hardware - Raspberry Pi Pico / Pico 2. - 3\u20135 LEDs con resistencias (220\u2013330 \u03a9) y cableado a los GPIO indicados.</p> <p>Conocimientos previos - M\u00e1scaras de bits, operaciones l\u00f3gicos.</p>"},{"location":"Tareas/tarea2/#contador-binario-de-4-bits","title":"Contador binario de 4 bits","text":""},{"location":"Tareas/tarea2/#nombre-del-codigo","title":"Nombre del c\u00f3digo","text":"<p>Contador binario (4 bits)</p>"},{"location":"Tareas/tarea2/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<p>Genera un contador binario ascendente de 4 bits. Los LEDs muestran los valores de 0 a 15, actualizando cada 500 ms.</p>"},{"location":"Tareas/tarea2/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define A 0\n#define B 1\n#define C 2\n#define D 3\n\nint main() {\n    const uint32_t MASK = (1u&lt;&lt;A) | (1u&lt;&lt;B) | (1u&lt;&lt;C) | (1u&lt;&lt;D);\n\n    gpio_init_mask(MASK);\n    gpio_set_dir_masked(MASK, MASK);\n\n    while (true) {\n        for (uint8_t i = 0; i &lt; 16; i++) {\n            // Escribe i en los pines A..D\n            gpio_put_masked(MASK, (uint32_t)i &lt;&lt; A);\n            sleep_ms(500);\n        }\n    }\n}\n</code></pre>"},{"location":"Tareas/tarea2/#esquematico-de-conexion","title":"Esquem\u00e1tico de conexi\u00f3n","text":""},{"location":"Tareas/tarea2/#video","title":"Video","text":""},{"location":"Tareas/tarea2/#barrido-de-leds","title":"Barrido de LEDs","text":""},{"location":"Tareas/tarea2/#nombre-del-codigo_1","title":"Nombre del c\u00f3digo","text":"<p>Barrido de LEDs (\u201cping-pong\u201d)</p>"},{"location":"Tareas/tarea2/#que-debe-hacer_1","title":"Qu\u00e9 debe hacer","text":"<p>Enciende un LED a la vez en orden ascendente (0\u21921\u21922\u21923\u21924) y luego descendente (4\u21923\u21922\u21921), repitiendo la secuencia.</p>"},{"location":"Tareas/tarea2/#codigo_1","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define A 0   \n#define B 1   \n#define C 2   \n#define D 3 \n#define E 4  \n\nint main() {\n    const uint32_t MASK = (1u&lt;&lt;A) | (1u&lt;&lt;B) | (1u&lt;&lt;C) | (1u&lt;&lt;D) | (1u&lt;&lt;E);\n\n    gpio_init_mask(MASK);\n    gpio_set_dir_out_masked(MASK);\n    gpio_clr_mask(MASK);\n\n    while (true) {\n        // Subida: 0..4\n        for (int i = 0; i &lt; 5; ++i) {\n            gpio_clr_mask(MASK);\n            gpio_set_mask(1u &lt;&lt; i);\n            sleep_ms(300);\n        }\n        // Bajada: 3..1 (evita repetir extremos 4 y 0)\n        for (int i = 3; i &gt; 0; --i) {\n            gpio_clr_mask(MASK);\n            gpio_set_mask(1u &lt;&lt; i);\n            sleep_ms(300);\n        }\n    }\n}\n</code></pre>"},{"location":"Tareas/tarea2/#esquematico-de-conexion_1","title":"Esquem\u00e1tico de conexi\u00f3n","text":""},{"location":"Tareas/tarea2/#video_1","title":"Video","text":""},{"location":"Tareas/tarea2/#secuencia-en-codigo-gray","title":"Secuencia en c\u00f3digo Gray","text":""},{"location":"Tareas/tarea2/#nombre-del-codigo_2","title":"Nombre del c\u00f3digo","text":"<p>Secuencia en c\u00f3digo Gray (3 bits)</p>"},{"location":"Tareas/tarea2/#que-debe-hacer_2","title":"Qu\u00e9 debe hacer","text":"<p>Muestra la secuencia Gray de 3 bits: en cada transici\u00f3n solo cambia 1 bit. Se usa la f\u00f3rmula <code>gray = n ^ (n &gt;&gt; 1)</code>.</p>"},{"location":"Tareas/tarea2/#codigo_2","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define A 0\n#define B 1\n#define C 2\n\nstatic inline uint8_t bin_to_gray(uint8_t n) {\n    return (uint8_t)(n ^ (n &gt;&gt; 1));\n}\n\nint main() {\n    const uint32_t MASK = (1u&lt;&lt;A) | (1u&lt;&lt;B) | (1u&lt;&lt;C);\n\n    gpio_init_mask(MASK);\n    gpio_set_dir_masked(MASK, MASK);\n\n    while (true) {\n        for (uint8_t i = 0; i &lt; 8; i++) {\n            uint8_t gray = bin_to_gray(i);\n            // Escribe gray en pines A..C\n            gpio_put_masked(MASK, (uint32_t)gray &lt;&lt; A);\n            sleep_ms(500);\n        }\n    }\n}\n</code></pre>"},{"location":"Tareas/tarea2/#esquematico-de-conexion_2","title":"Esquem\u00e1tico de conexi\u00f3n","text":""},{"location":"Tareas/tarea2/#video_2","title":"Video","text":""},{"location":"Tareas/tarea2/#6-resultados-y-conclusiones","title":"6) Resultados y conclusiones","text":"<ul> <li>Las m\u00e1scaras simplifican la configuraci\u00f3n y escritura simult\u00e1nea de varios GPIO.  </li> <li>El barrido demuestra control individual y temporizaci\u00f3n consistente.  </li> <li>La secuencia Gray valida operaciones bit a bit (<code>^</code>, <code>&gt;&gt;</code>) y su aplicaci\u00f3n pr\u00e1ctica en minimizar cambios simult\u00e1neos.</li> </ul> <p>Pr\u00f3ximos pasos: portar a interrupciones/PIO</p>"},{"location":"Tareas/tarea3/","title":"\ud83d\udcd8 Tarea 3 \u2014 Inputs con l\u00f3gica y m\u00e1scaras","text":"<p>Dos pr\u00e1cticas con botones y LEDs en Raspberry Pi Pico: compuertas l\u00f3gicas AND/OR/XOR y selector c\u00edclico con avance/retroceso.</p>"},{"location":"Tareas/tarea3/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Inputs con l\u00f3gica y m\u00e1scaras  </li> <li>Autor: Carlos Ernesto Camacho Gonz\u00e1lez </li> <li>Curso / Asignatura: Sistemas Embebidos  </li> <li>Fecha: 01/09/2025  </li> <li>Descripci\u00f3n breve: Se leen botones pull-up (presionado=0) para generar salidas en LEDs usando operadores l\u00f3gicos y m\u00e1scaras. Se implementa antirrebote por detecci\u00f3n de flanco.</li> </ul> <p>Consejo</p> <p>Con pull-up, el bot\u00f3n presionado lee <code>0</code>. Invierte con <code>!gpio_get(pin)</code> para tratar \u201cpresionado = 1\u201d.</p>"},{"location":"Tareas/tarea3/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Practicar lectura de entradas digitales y generaci\u00f3n de salidas usando operadores l\u00f3gicos y m\u00e1scaras.</li> <li>Espec\u00edficos:</li> <li>Implementar AND/OR/XOR en hardware con botones y LEDs.</li> <li>Dise\u00f1ar un selector c\u00edclico con avance y retroceso sin repetici\u00f3n mientras se mantiene presionado.</li> <li>Aplicar antirrebote por flanco con variables de estado previo.</li> </ul>"},{"location":"Tareas/tarea3/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Lectura de GPIO, pull-ups internos, escritura en GPIO, m\u00e1scaras y detecci\u00f3n por flanco.  </li> <li>No incluye: interrupciones.</li> </ul>"},{"location":"Tareas/tarea3/#4-requisitos","title":"4) Requisitos","text":"<p>Hardware - Raspberry Pi Pico / Pico 2. - 6 botones (pull-up) y 7\u20138 LEDs con resistencias.</p> <p>Conocimientos previos - Operadores l\u00f3gicos y operaciones de bits. - Pull-up/pull-down y l\u00f3gica activa-baja.</p>"},{"location":"Tareas/tarea3/#compuertas-basicas-and-or-xor-con-2-botones-por-puerta","title":"Compuertas b\u00e1sicas AND / OR / XOR con 2 botones por puerta","text":""},{"location":"Tareas/tarea3/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<p>Con botones pull-up (presionado=0) se encienden tres LEDs que muestran el resultado de AND, OR y XOR. En los videos se ejemplifican las combinaciones.</p>"},{"location":"Tareas/tarea3/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n\n// Pines AND\n#define BTN_A 0      \n#define BTN_B 1    \n#define LED0  6\n// Pines OR\n#define BTN_C 2     \n#define BTN_D 3    \n#define LED1  7\n// Pines XOR\n#define BTN_E 4      \n#define BTN_F 5    \n#define LED2  8\n\nstatic inline bool ANDf(void) {\n    bool A_PRESS = !gpio_get(BTN_A);\n    bool B_PRESS = !gpio_get(BTN_B);\n    return (A_PRESS &amp;&amp; B_PRESS);\n}\n\nstatic inline bool ORf(void) {\n    bool C_PRESS = !gpio_get(BTN_C);\n    bool D_PRESS = !gpio_get(BTN_D);\n    return (C_PRESS || D_PRESS);\n}\n\nstatic inline bool XORf(void) {\n    bool E_PRESS = !gpio_get(BTN_E);\n    bool F_PRESS = !gpio_get(BTN_F);\n    return (E_PRESS ^ F_PRESS);\n}\n\nint main(void) {\n    // LEDs salida\n    gpio_init(LED0); gpio_set_dir(LED0, GPIO_OUT);\n    gpio_init(LED1); gpio_set_dir(LED1, GPIO_OUT);\n    gpio_init(LED2); gpio_set_dir(LED2, GPIO_OUT);\n\n    // Botones con pull-up\n    gpio_init(BTN_A); gpio_set_dir(BTN_A, GPIO_IN); gpio_pull_up(BTN_A);\n    gpio_init(BTN_B); gpio_set_dir(BTN_B, GPIO_IN); gpio_pull_up(BTN_B);\n\n    gpio_init(BTN_C); gpio_set_dir(BTN_C, GPIO_IN); gpio_pull_up(BTN_C);\n    gpio_init(BTN_D); gpio_set_dir(BTN_D, GPIO_IN); gpio_pull_up(BTN_D);\n\n    gpio_init(BTN_E); gpio_set_dir(BTN_E, GPIO_IN); gpio_pull_up(BTN_E);\n    gpio_init(BTN_F); gpio_set_dir(BTN_F, GPIO_IN); gpio_pull_up(BTN_F);\n\n    while (true) {\n        gpio_put(LED0, ANDf());\n        gpio_put(LED1, ORf());\n        gpio_put(LED2, XORf());\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"Tareas/tarea3/#esquematico-de-conexion-and","title":"Esquem\u00e1tico de conexi\u00f3n AND","text":""},{"location":"Tareas/tarea3/#compuerta-and","title":"Compuerta AND","text":""},{"location":"Tareas/tarea3/#esquematico-de-conexion-or","title":"Esquem\u00e1tico de conexi\u00f3n OR","text":""},{"location":"Tareas/tarea3/#compuerta-or","title":"Compuerta OR","text":""},{"location":"Tareas/tarea3/#esquematico-de-conexion-xor","title":"Esquem\u00e1tico de conexi\u00f3n XOR","text":""},{"location":"Tareas/tarea3/#compuerta-xor","title":"Compuerta XOR","text":""},{"location":"Tareas/tarea3/#selector-ciclico-de-4-leds-con-avanceretroceso-antirrebote-por-flanco","title":"Selector c\u00edclico de 4 LEDs con avance/retroceso (antirrebote por flanco)","text":""},{"location":"Tareas/tarea3/#que-debe-hacer_1","title":"Qu\u00e9 debe hacer","text":"<p>Se mantiene un solo LED encendido entre LED0..LED3. Un bot\u00f3n AVANZA (0\u21921\u21922\u21923\u21920) y otro RETROCEDE (0\u21923\u21922\u21921\u21920). Un push = un paso (si se deja presionado no repite gracias a la detecci\u00f3n de flanco).</p>"},{"location":"Tareas/tarea3/#codigo_1","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n\n#define BTN_PREV 0      \n#define BTN_NEXT 1    \n#define LED0   2\n#define LED1   3\n#define LED2   4\n#define LED3   5\n\nuint8_t STATE = LED0 - 1;\n\nint main(void) {\n    const uint8_t LEDs_M = (1u &lt;&lt; LED0 | 1u &lt;&lt; LED1 | 1u &lt;&lt; LED2 | 1u &lt;&lt; LED3);\n\n    gpio_init_mask(LEDs_M);\n    gpio_set_dir_out_masked(LEDs_M);\n    gpio_set_mask(LEDs_M);   \n    gpio_clr_mask(LEDs_M);\n\n    gpio_init(BTN_PREV);\n    gpio_set_dir(BTN_PREV, GPIO_IN);\n    gpio_pull_up(BTN_PREV);\n\n    gpio_init(BTN_NEXT);\n    gpio_set_dir(BTN_NEXT, GPIO_IN);\n    gpio_pull_up(BTN_NEXT);\n\n    bool NEXT_PREVSTATE = 1;\n    bool PREV_PREVSTATE = 1;\n\n    while (true) {\n        bool NEXT_STATE = !gpio_get(BTN_NEXT);\n        bool PREV_STATE = !gpio_get(BTN_PREV);\n\n        // Siguiente LED\n        if (NEXT_STATE &amp;&amp; !NEXT_PREVSTATE) {\n            if (STATE == LED3) {\n                STATE = LED0;\n            } else {\n                STATE ++;\n            }\n            gpio_clr_mask(LEDs_M);                \n            gpio_set_mask(1 &lt;&lt; STATE);              \n        }\n\n        // Anterior LED\n        if (PREV_STATE &amp;&amp; !PREV_PREVSTATE) {\n            if (STATE == LED0) {\n                STATE = LED3;\n            } else {\n                STATE --;\n            }\n            gpio_clr_mask(LEDs_M);                \n            gpio_set_mask(1 &lt;&lt; STATE);              \n        }\n\n        NEXT_PREVSTATE = NEXT_STATE;\n        PREV_PREVSTATE = PREV_STATE;\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"Tareas/tarea3/#demostracion","title":"Demostraci\u00f3n","text":""},{"location":"Tareas/tarea3/#5-resultados-y-conclusiones","title":"5) Resultados y conclusiones","text":"<ul> <li> <p>Las compuertas AND/OR/XOR se implementan directamente con operadores l\u00f3gicos, cumpliendo \u201csin enumerar combinaciones\u201d.</p> </li> <li> <p>El selector c\u00edclico usa m\u00e1scaras para encender exactamente un LED.</p> </li> </ul>"},{"location":"Tareas/tarea4/","title":"\ud83d\udcd8 Tarea 4 \u2014 Mini-Pong con ISR (5 LEDs)","text":""},{"location":"Tareas/tarea4/#nombre-del-codigo","title":"Nombre del c\u00f3digo","text":"<p>Mini-Pong ISR (5 LEDs, 2 botones, RP2040)</p>"},{"location":"Tareas/tarea4/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<p>La \u201cpelota\u201d es un LED que recorre 5 LEDs en l\u00ednea (L1\u2192L5\u2192L1\u2026) a un ritmo fijo. Cada bot\u00f3n genera una interrupci\u00f3n (ISR) y solo cuenta si se presiona exactamente cuando la pelota est\u00e1 en el extremo de ese lado: BTN_L solo en L1, BTN_R solo en L5. Si coincide, rebota (invierte direcci\u00f3n). Si no, anota el rival: parpadea 3 veces su LED de punto, se reinicia en L3 y sale hacia quien anot\u00f3. Al encender, la pelota inicia en L3 y no se mueve hasta presionar un bot\u00f3n; arrancar\u00e1 en la direcci\u00f3n opuesta al bot\u00f3n presionado.</p>"},{"location":"Tareas/tarea4/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n// ---------- Pines ----------\n#define BTN_L  0   // Bot\u00f3n jugador IZQUIERDA\n#define BTN_R  1   // Bot\u00f3n jugador DERECHA\n#define PT_L   2   // LED punto IZQUIERDA\n#define PT_R   3   // LED punto DERECHA\n\n// L\u00ednea de 5 LEDs (L1..L5)\n#define L1 4       // extremo izquierdo\n#define L2 5\n#define L3 6       // centro\n#define L4 7\n#define L5 8       // extremo derecho\n\n// ---------- Par\u00e1metros ----------\nstatic const uint32_t STEP_MS  = 120; // ritmo de la pelota\nstatic const uint32_t BLINK_MS = 150; // parpadeo de punto (x3)\n\n// ---------- Estado ----------\nstatic const uint8_t LINE[5] = { L1, L2, L3, L4, L5 };\nstatic volatile bool START = false;     // detenido en L3 hasta primer toque\nstatic volatile int8_t dir = 0;         // -1 izq., +1 der.\nstatic volatile uint8_t idx = 2;        // 0..4 (L3=2)\nstatic volatile uint8_t cur_pin = L3;   // GPIO encendido actual\nstatic volatile bool HIT_L = false;     // golpe v\u00e1lido justo en L1\nstatic volatile bool HIT_R = false;     // golpe v\u00e1lido justo en L5\n\nstatic inline void show_ball(uint8_t new_idx){\n    idx = new_idx;\n    cur_pin = LINE[idx];\n    uint32_t mask_line = (1u&lt;&lt;L1)|(1u&lt;&lt;L2)|(1u&lt;&lt;L3)|(1u&lt;&lt;L4)|(1u&lt;&lt;L5);\n    gpio_clr_mask(mask_line);\n    gpio_set_mask(1u &lt;&lt; cur_pin);\n}\n\nstatic void blink_point(uint pin){\n    for(int i=0;i&lt;3;++i){ gpio_put(pin,1); sleep_ms(BLINK_MS); gpio_put(pin,0); sleep_ms(BLINK_MS); }\n}\n\nstatic void reset_center_and_go(bool to_right){\n    show_ball(2);         // L3\n    START = true;\n    dir = to_right ? +1 : -1;\n}\n\n// ISR: arranque y golpes exactos en extremos\nstatic void isr_buttons(uint gpio, uint32_t events){\n    if(!(events &amp; GPIO_IRQ_EDGE_FALL)) return; // flanco de bajada (pull-up)\n    if(!START){\n        if(gpio==BTN_L){ START=true; dir=+1; } // opuesta al bot\u00f3n\n        else if(gpio==BTN_R){ START=true; dir=-1; }\n        return;\n    }\n    if(gpio==BTN_L &amp;&amp; cur_pin==L1) HIT_L = true;\n    if(gpio==BTN_R &amp;&amp; cur_pin==L5) HIT_R = true;\n}\n\nint main(){\n    stdio_init_all();\n    // LEDs l\u00ednea\n    for(int i=0;i&lt;5;++i){ gpio_init(LINE[i]); gpio_set_dir(LINE[i],GPIO_OUT); gpio_put(LINE[i],0); }\n    // LEDs punto\n    gpio_init(PT_L); gpio_set_dir(PT_L,GPIO_OUT); gpio_put(PT_L,0);\n    gpio_init(PT_R); gpio_set_dir(PT_R,GPIO_OUT); gpio_put(PT_R,0);\n    // Botones (pull-up)\n    gpio_init(BTN_L); gpio_set_dir(BTN_L,GPIO_IN); gpio_pull_up(BTN_L);\n    gpio_init(BTN_R); gpio_set_dir(BTN_R,GPIO_IN); gpio_pull_up(BTN_R);\n    // ISR\n    gpio_set_irq_enabled_with_callback(BTN_L, GPIO_IRQ_EDGE_FALL, true, &amp;isr_buttons);\n    gpio_set_irq_enabled(BTN_R, GPIO_IRQ_EDGE_FALL, true);\n\n    show_ball(2); // L3\n    START=false;\n\n    absolute_time_t last = get_absolute_time();\n    while(true){\n        if(to_ms_since_boot(get_absolute_time()) - to_ms_since_boot(last) &lt; STEP_MS){\n            tight_loop_contents(); continue;\n        }\n        last = get_absolute_time();\n\n        if(!START){ show_ball(2); continue; }\n\n        int8_t next = idx + dir;\n        if(next&lt;0) next=0; if(next&gt;4) next=4;\n        show_ball(next);\n\n        if(idx==0){ // L1\n            if(HIT_L){ dir=+1; }                 // rebote\n            else{ blink_point(PT_R); reset_center_and_go(true); } // punto derecha\n            HIT_L=false;\n        }\n        if(idx==4){ // L5\n            if(HIT_R){ dir=-1; }                 // rebote\n            else{ blink_point(PT_L); reset_center_and_go(false);} // punto izquierda\n            HIT_R=false;\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Tareas/tarea4/#esquematico-de-conexion-xor","title":"Esquem\u00e1tico de conexi\u00f3n XOR","text":""},{"location":"Tareas/tarea4/#video","title":"video","text":""},{"location":"Tareas/tarea5/","title":"\ud83d\udcd8 Tarea 5 \u2014 Ejercicios de medicion","text":"<p>Genera una onda cuadrada con ALARM0 en interrupci\u00f3n (ISR), con rearme acumulativo y periodo nominal definido. Luego compara modo \u00b5s vs modo ciclos (clk_sys) en el RP2350 (Pico 2).</p>"},{"location":"Tareas/tarea5/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Temporizador de sistema \u2014 ALARM0 y medici\u00f3n de jitter  </li> <li>Autor: Carlos Ernesto Camacho Gonz\u00e1lez </li> <li>Curso / Asignatura: Sistemas Embebidos  </li> <li>Fecha: 15/09/2025  </li> <li>Descripci\u00f3n breve: Se usa el timer del sistema para alternar (toggle) un GPIO desde la ISR de ALARM0.</li> </ul> <p>Consejo</p>"},{"location":"Tareas/tarea5/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Generar una onda cuadrada estable con ALARM0 y caracterizar su jitter.</li> <li>Espec\u00edficos:</li> <li>Implementar ISR de ALARM0 con rearme acumulativo.</li> <li>Medir periodo, jitter p-p y RMS con osciloscopio.</li> <li>Comparar precisi\u00f3n entre modo \u00b5s y modo ciclos (clk_sys).</li> </ul>"},{"location":"Tareas/tarea5/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: GPIO, IRQ, system timer ALARM0, medici\u00f3n con osciloscopio.</li> <li>No incluye: PIO/PWM/DMA.</li> </ul>"},{"location":"Tareas/tarea5/#4-requisitos","title":"4) Requisitos","text":"<p>Hardware - Raspberry Pi Pico 2 (RP2350). - 1 LED + resistencia (o s\u00f3lo el GPIO medido con sonda).</p> <p>Conocimientos previos - Interrupciones, GPIO, y conceptos de jitter/RMS.</p>"},{"location":"Tareas/tarea5/#6-codigo-1","title":"6) C\u00f3digo 1","text":"<pre><code>// Blink con timer (SDK alto nivel): cambia BLINK_MS para ajustar\n#include \"pico/stdlib.h\"\n#include \"pico/time.h\"\n\n#define LED_PIN 0                      // &lt;-- LED externo en GP0\nstatic const int BLINK_MS = 500;       // \"toggle\" cada 500 ms (periodo completo ~1 s)\n\nbool blink_cb(repeating_timer_t *t) {\n    static bool on = false;\n    gpio_put(LED_PIN, on = !on);   // toggle\n    return true;                   // seguir repitiendo\n}\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n\n    repeating_timer_t timer;\n    add_repeating_timer_ms(BLINK_MS, blink_cb, NULL, &amp;timer);\n\n    while (true) {\n        tight_loop_contents();     // trabajo pesado va aqu\u00ed, no en la ISR\n    }\n}\n</code></pre>"},{"location":"Tareas/tarea5/#7-codigo-2","title":"7) C\u00f3digo 2","text":"<pre><code>// Blink con timer de sistema (bajo nivel): ALARM0 + IRQ con rearme acumulativo\n#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n#include \"hardware/structs/sio.h\"\n\n#define LED_PIN    0                    // &lt;-- LED externo en GP0\n#define ALARM_NUM  0                    // usaremos ALARM0\n\n// N\u00famero de IRQ asociado a ALARM0\n#define ALARM_IRQ  timer_hardware_alarm_get_irq_num(timer_hw, ALARM_NUM)\n\n// pr\u00f3ximo instante (en \u00b5s) en los 32 bits bajos del contador\nstatic volatile uint32_t next_deadline;\n// por defecto el timer cuenta en \u00b5s\nstatic volatile uint32_t intervalo_us = 500000u; // &lt;-- \"toggle\" cada 500 ms (periodo completo ~1 s)\n\nvoid on_alarm_irq(void) {\n    // Limpia la IRQ de ALARM0 (write-1-to-clear)\n    hw_set_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM);\n\n    // Toggle del LED\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN;\n\n    // Rearme ACUMULATIVO (evita deriva si la ISR se retrasa)\n    next_deadline += intervalo_us;\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n}\n\nint main() {\n    stdio_init_all();\n\n    // LED de salida\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n    gpio_put(LED_PIN, 0);\n\n    // Primer deadline\n    uint32_t now_us = timer_hw-&gt;timerawl;     // 32 bits bajos (\u00b5s)\n    next_deadline = now_us + intervalo_us;\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n\n    // Enlaza e inicia IRQ\n    irq_set_exclusive_handler(ALARM_IRQ, on_alarm_irq);\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM);\n    irq_set_enabled(ALARM_IRQ, true);\n\n    while (true) {\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"Tareas/tarea5/#7-esquematico-raspberry-pi-pico-2-led-en-gp1","title":"7) Esquematico - Raspberry Pi Pico 2 (LED en GP1)","text":"<p> Figura 1.</p>"},{"location":"Tareas/tarea5/#8-resultados","title":"8) Resultados","text":"<p>Programa 1</p> <ul> <li> <p>Par\u00e1metro del timer: 1.000 s</p> </li> <li> <p>Medici\u00f3n con cursores: \u0394t \u2248 1.001 s </p> </li> <li> <p>Periodo completo de la onda: \u2248 2.002 s</p> </li> </ul> <p> Figura 2. Medici\u00f3n con SDK alto nivel.</p> <p>Programa 2</p> <ul> <li> <p>Par\u00e1metro del timer: 1.000 s</p> </li> <li> <p>Medici\u00f3n con cursores: \u0394t \u2248 1.000\u20131.001 s</p> </li> <li> <p>Periodo completo de la onda: \u2248 2.000\u20132.002 s</p> </li> </ul> <p> Figura 3. Medici\u00f3n con ALARM0 + ISR.</p>"},{"location":"Tareas/tarea5/#9-conclusiones-rapidas","title":"9) Conclusiones r\u00e1pidas","text":"<ul> <li>Ambos m\u00e9todos cumplen el periodo esperado; el desv\u00edo de ~+1 ms (~0.1%) est\u00e1 dentro del l\u00edmite de medici\u00f3n de esa configuraci\u00f3n.</li> </ul>"},{"location":"Tareas/tarea6/","title":"\ud83d\udcd8 Tarea 6 \u2014 Ejercicios de Programaci\u00f3n","text":""},{"location":"Tareas/tarea6/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Multialarmas / Control de velocidad en Pong  </li> <li>Autor: Carlos Ernesto Camacho Gonz\u00e1lez  </li> <li>Curso / Asignatura: Sistemas Embebidos  </li> <li>Fecha: 16/09/2025  </li> <li>Descripci\u00f3n breve: </li> <li>Ejercicio 1: Cuatro LEDs a distintas frecuencias con temporizador de software (sin interrupciones).  </li> <li>Ejercicio 2: Pong con dos botones para subir/bajar la velocidad sin <code>delay</code> usando ALARM0/1 y rearme acumulativo.</li> </ul>"},{"location":"Tareas/tarea6/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Generar y controlar temporizaciones independientes para m\u00faltiples salidas.  </li> <li>Ajustar la velocidad de un juego sin bloquear el bucle principal.  </li> <li>Usar rearme acumulativo y antirrebote por flanco.</li> </ul>"},{"location":"Tareas/tarea6/#3-ejercicio-1-cuatro-alarmas-cuatro-leds-a-distintas-frecuencias-sin-interrupciones","title":"3) Ejercicio 1 \u2014 Cuatro alarmas / cuatro LEDs a distintas frecuencias (sin interrupciones)","text":""},{"location":"Tareas/tarea6/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<p>Configurar cuatro LEDs en pines distintos. Cada LED alterna (toggle) con su intervalo propio usando un temporizador de software basado en <code>time_us_32()</code> (sin IRQ).</p>"},{"location":"Tareas/tarea6/#codigo","title":"C\u00f3digo","text":"<pre><code>// Cuatro LEDs a distintas frecuencias (RP2350 / Pico 2) SIN interrupciones.\n// LED0=GPIO 1, LED1=GPIO 0, LED2=GPIO 2, LED3=GPIO 3.\n\n#include \"pico/stdlib.h\"\n#include \"pico/time.h\"\n#include \"hardware/gpio.h\"\n\n#define LED0_PIN 1   // antes: PICO_DEFAULT_LED_PIN\n#define LED1_PIN 0\n#define LED2_PIN 2\n#define LED3_PIN 3\n\nstatic const uint8_t PINES[4] = { LED0_PIN, LED1_PIN, LED2_PIN, LED3_PIN };\n\n// Intervalo ENTRE toggles (el per\u00edodo visible ON+OFF es el doble)\nstatic const uint32_t INTERVALO_US[4] = {\n    300000u, // GPIO 1: 300 ms\n    200000u, // GPIO 0: 200 ms\n    120000u, // GPIO 2: 120 ms\n     80000u  // GPIO 3: 80 ms\n};\n\nstatic uint32_t next_us[4];\n\nint main(void) {\n    for (int i = 0; i &lt; 4; ++i) {\n        gpio_init(PINES[i]);\n        gpio_set_dir(PINES[i], GPIO_OUT);\n        gpio_put(PINES[i], 0);\n    }\n\n    uint32_t now = time_us_32();\n    for (int i = 0; i &lt; 4; ++i) next_us[i] = now + INTERVALO_US[i];\n\n    while (true) {\n        now = time_us_32();\n        for (int i = 0; i &lt; 4; ++i) {\n            if ((int32_t)(now - next_us[i]) &gt;= 0) {\n                gpio_xor_mask(1u &lt;&lt; PINES[i]);\n                next_us[i] += INTERVALO_US[i];   // rearme acumulativo\n            }\n        }\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"Tareas/tarea6/#esquematico-de-conexion","title":"Esquematico de conexi\u00f3n","text":"<p> Figura 1.</p>"},{"location":"Tareas/tarea6/#video","title":"video","text":""},{"location":"Tareas/tarea6/#4-ejercicio-2-pong-dos-botones-para-subirbajar-velocidad-sin-delay","title":"4) Ejercicio 2 \u2014 Pong: dos botones para subir/bajar velocidad (sin delay)","text":""},{"location":"Tareas/tarea6/#que-debe-hacer_1","title":"Qu\u00e9 debe hacer","text":"<p>A\u00f1adir BTN_MAS (\u2191 velocidad) y BTN_MENOS (\u2193 velocidad). El tempo del juego se controla con ALARMA_JUEGO (modo \u00b5s), rearme acumulativo y antirrebote. El parpadeo de punto va con ALARMA_PUNTO (no bloqueante).</p>"},{"location":"Tareas/tarea6/#codigo_1","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n#include \"hardware/gpio.h\"\n\n#define BTN_J1 0   // Bot\u00f3n jugador izquierda\n#define BTN_J2 1   // Bot\u00f3n jugador derecha\n#define LED_J1 2   // LED indicador puntos J1\n#define LED_J2 3   // LED indicador puntos J2\n#define LED0 4     // Posici\u00f3n 0 de LED\n#define LED1 5\n#define LED2 6     // Centro de LEDs\n#define LED3 7\n#define LED4 8     // Posici\u00f3n 4 de LED\n#define RESET 9    // Bot\u00f3n de reinicio\n\n// Botones NUEVOS\n#define BTN_MAS   10  // Subir velocidad\n#define BTN_MENOS 11  // Bajar velocidad\n\n// Alarmas del timer\n#define ALARMA_JUEGO_NUM  0  // tick de juego\n#define ALARMA_PUNTO_NUM  1  // parpadeo de punto\n#define IRQ_ALARMA_JUEGO  timer_hardware_alarm_get_irq_num(timer_hw, ALARMA_JUEGO_NUM)\n#define IRQ_ALARMA_PUNTO  timer_hardware_alarm_get_irq_num(timer_hw, ALARMA_PUNTO_NUM)\n\n// Velocidades (ms)\n#define VEL_PELOTA 100\n#define VEL_REBOTE 300\n\n// Rango y paso de velocidad (us)\n#define VEL_MIN_US         40000u\n#define VEL_MAX_US        400000u\n#define VEL_PASO_US        20000u    // salto entre us\n#define ANTIRREBOTE_VEL_US 120000u   // antirrebote para botones de velocidad\n\nuint8_t POS = LED2;     // Pelota arranca en el centro\nbool DIR = 1;           // 1 = derecha, 0 = izquierda\nbool START = false;     // Juego detenido al inicio\n\nvolatile bool GOLPE_J1 = false;\nvolatile bool GOLPE_J2 = false;\nvolatile bool START_J1 = false;\nvolatile bool START_J2 = false;\nvolatile bool RESET_STATE = false;\n\n// M\u00e1scaras\nuint32_t LEDS_MASK;\nstatic uint32_t MASCARA_LEDS_POS;     // solo LEDs de posici\u00f3n, no marca\n\n// Tiempo y tick\nstatic inline uint32_t microsegundos(void){ return timer_hw-&gt;timerawl; }\nstatic volatile uint32_t VEL_PELOTA_US = (uint32_t)VEL_PELOTA * 1000u; // periodo del tick en \u00b5s\nstatic volatile uint32_t PROXIMO_TICK_US = 0;\nstatic volatile uint32_t ULTIMO_CAMBIO_VEL_US = 0; // antirrebote de BTN_MAS/BTN_MENOS\n\n// Ventana de rebote fija en tiempo\n#define REBOTE_US ((uint32_t)VEL_REBOTE * 1000u)\nstatic volatile bool EN_PARED = false;\nstatic volatile uint32_t VENTANA_HASTA_US = 0;\n\n// Parpadeo no bloqueante (ALARMA_PUNTO)\nstatic volatile bool PARPADEO_ACTIVO = false;\nstatic volatile uint8_t  PIN_LED_PARPADEO = 0;\nstatic volatile uint8_t  PARPADEOS_RESTANTES = 0;\nstatic volatile uint32_t PROXIMO_PARPADEO_US = 0;\n#define PARPADEO_MEDIO_US 200000u // 200 ms ON/OFF\n\n// Prototipos requeridos\nstatic void PONG(uint PIN, uint32_t EVENT_MASK);\nvoid BLINK(uint8_t LED);\nvoid REINICIAR();\nvoid MOVER_PELOTA(void);\n\n// ---- ISRs de alarmas\nstatic void irq_alarma_juego(void){\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARMA_JUEGO_NUM);\n    MOVER_PELOTA();\n    PROXIMO_TICK_US += VEL_PELOTA_US;                 // rearme acumulativo\n    timer_hw-&gt;alarm[ALARMA_JUEGO_NUM] = PROXIMO_TICK_US;\n}\n\nstatic void irq_alarma_punto(void){\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARMA_PUNTO_NUM);\n\n    if (!PARPADEO_ACTIVO || PARPADEOS_RESTANTES == 0){\n        gpio_put(PIN_LED_PARPADEO, 0);\n        PARPADEO_ACTIVO = false;\n        return;\n    }\n    sio_hw-&gt;gpio_togl = (1u &lt;&lt; PIN_LED_PARPADEO);\n    PARPADEOS_RESTANTES--;\n    PROXIMO_PARPADEO_US += PARPADEO_MEDIO_US;         // rearme acumulativo\n    timer_hw-&gt;alarm[ALARMA_PUNTO_NUM] = PROXIMO_PARPADEO_US;\n}\n\nint main() {\n    // LEDs\n    LEDS_MASK = (1u &lt;&lt; LED_J1) | (1u &lt;&lt; LED_J2) | (1u &lt;&lt; LED0) | (1u &lt;&lt; LED1) |\n                (1u &lt;&lt; LED2) | (1u &lt;&lt; LED3) | (1u &lt;&lt; LED4);\n    MASCARA_LEDS_POS = (1u &lt;&lt; LED0) | (1u &lt;&lt; LED1) | (1u &lt;&lt; LED2) | (1u &lt;&lt; LED3) | (1u &lt;&lt; LED4);\n\n    gpio_init_mask(LEDS_MASK);\n    gpio_set_dir_masked(LEDS_MASK, LEDS_MASK);\n    gpio_clr_mask(LEDS_MASK);\n\n    // Botones\n    gpio_init(BTN_J1);   gpio_set_dir(BTN_J1, GPIO_IN);   gpio_pull_up(BTN_J1);\n    gpio_init(BTN_J2);   gpio_set_dir(BTN_J2, GPIO_IN);   gpio_pull_up(BTN_J2);\n    gpio_init(RESET);    gpio_set_dir(RESET,  GPIO_IN);   gpio_pull_up(RESET);\n    gpio_init(BTN_MAS);  gpio_set_dir(BTN_MAS, GPIO_IN);  gpio_pull_up(BTN_MAS);\n    gpio_init(BTN_MENOS);gpio_set_dir(BTN_MENOS, GPIO_IN);gpio_pull_up(BTN_MENOS);\n\n    gpio_set_mask(1u &lt;&lt; POS); // LED inicial en centro\n\n    // IRQ GPIO por flanco de bajada\n    gpio_set_irq_enabled_with_callback(BTN_J1, GPIO_IRQ_EDGE_FALL, true, &amp;PONG);\n    gpio_set_irq_enabled(BTN_J2,   GPIO_IRQ_EDGE_FALL, true);\n    gpio_set_irq_enabled(RESET,    GPIO_IRQ_EDGE_FALL, true);\n    gpio_set_irq_enabled(BTN_MAS,  GPIO_IRQ_EDGE_FALL, true);\n    gpio_set_irq_enabled(BTN_MENOS,GPIO_IRQ_EDGE_FALL, true);\n\n    // Timer de sistema en \u00b5s\n    timer_hw-&gt;source = 0u;                         // base de tiempo en \u00b5s (RP2350)\n    uint32_t ahora = microsegundos();\n\n    // Programa ALARMA_JUEGO (primer tick)\n    PROXIMO_TICK_US = ahora + VEL_PELOTA_US;\n    timer_hw-&gt;alarm[ALARMA_JUEGO_NUM] = PROXIMO_TICK_US;\n\n    // Limpia flags, registra handlers y habilita\n    hw_clear_bits(&amp;timer_hw-&gt;intr, (1u &lt;&lt; ALARMA_JUEGO_NUM) | (1u &lt;&lt; ALARMA_PUNTO_NUM));\n    irq_set_exclusive_handler(IRQ_ALARMA_JUEGO,  irq_alarma_juego);\n    irq_set_exclusive_handler(IRQ_ALARMA_PUNTO,  irq_alarma_punto);\n    hw_set_bits(&amp;timer_hw-&gt;inte, (1u &lt;&lt; ALARMA_JUEGO_NUM) | (1u &lt;&lt; ALARMA_PUNTO_NUM));\n    irq_set_enabled(IRQ_ALARMA_JUEGO,  true);\n    irq_set_enabled(IRQ_ALARMA_PUNTO,  true);\n\n    while (true) { tight_loop_contents(); }\n}\n\n// ---- ISR GPIO\nstatic void PONG(uint PIN, uint32_t EVENT_MASK) {\n    if (EVENT_MASK &amp; GPIO_IRQ_EDGE_FALL) {\n        if (PIN == BTN_J1) {\n            if (!START) START_J1 = true;\n            else if (POS == LED0) GOLPE_J1 = true;\n        } else if (PIN == BTN_J2) {\n            if (!START) START_J2 = true;\n            else if (POS == LED4) GOLPE_J2 = true;\n        } else if (PIN == RESET) {\n            RESET_STATE = true;\n        } else if (PIN == BTN_MAS || PIN == BTN_MENOS) {\n            uint32_t t = microsegundos();\n            // antirrebote botones de velocidad\n            if ((int32_t)(t - ULTIMO_CAMBIO_VEL_US) &gt; (int32_t)ANTIRREBOTE_VEL_US) {\n                if (PIN == BTN_MAS) {\n                    // m\u00e1s r\u00e1pido = menor periodo\n                    if (VEL_PELOTA_US &gt; VEL_MIN_US + VEL_PASO_US - 1) VEL_PELOTA_US -= VEL_PASO_US;\n                    else VEL_PELOTA_US = VEL_MIN_US;\n                } else {\n                    // m\u00e1s lento = mayor periodo\n                    if (VEL_PELOTA_US &lt; VEL_MAX_US - VEL_PASO_US + 1) VEL_PELOTA_US += VEL_PASO_US;\n                    else VEL_PELOTA_US = VEL_MAX_US;\n                }\n                // re-alinear pr\u00f3ximo tick para notar el cambio de inmediato\n                PROXIMO_TICK_US = t + VEL_PELOTA_US;\n                timer_hw-&gt;alarm[ALARMA_JUEGO_NUM] = PROXIMO_TICK_US;\n                ULTIMO_CAMBIO_VEL_US = t;\n            }\n        }\n    }\n    gpio_acknowledge_irq(PIN, EVENT_MASK);\n}\n\n// BLINK del original: ahora inicia parpadeo no bloqueante\nvoid BLINK(uint8_t LED) {\n    PIN_LED_PARPADEO = LED;\n    PARPADEOS_RESTANTES = 6; // 3 destellos ON/OFF\n    gpio_put(PIN_LED_PARPADEO, 0);\n    PARPADEO_ACTIVO = true;\n    PROXIMO_PARPADEO_US = microsegundos() + PARPADEO_MEDIO_US;\n    timer_hw-&gt;alarm[ALARMA_PUNTO_NUM] = PROXIMO_PARPADEO_US;\n}\n\nvoid REINICIAR() {\n    POS = LED2;\n    START = false;\n    GOLPE_J1 = false;\n    GOLPE_J2 = false;\n    START_J1 = false;\n    START_J2 = false;\n    EN_PARED = false;\n    PARPADEO_ACTIVO = false;\n    gpio_put(LED_J1, 0);\n    gpio_put(LED_J2, 0);\n    gpio_clr_mask(MASCARA_LEDS_POS);\n    gpio_set_mask(1u &lt;&lt; POS); // LED centro\n}\n\nvoid MOVER_PELOTA() {\n    uint32_t tnow = microsegundos();\n\n    if (RESET_STATE) {\n        REINICIAR();\n        RESET_STATE = false;\n        return;\n    }\n\n    if (!START) {\n        if (START_J1) { DIR = 1; START = true; START_J1 = false; }\n        else if (START_J2) { DIR = 0; START = true; START_J2 = false; }\n        gpio_set_mask(1u &lt;&lt; POS); // LED centro\n        return;\n    }\n\n    // Ventana fija cuando est\u00e1 en pared\n    if (EN_PARED) {\n        if ((int32_t)(tnow - VENTANA_HASTA_US) &gt;= 0) {\n            if (POS == LED0) {\n                if (GOLPE_J1) { DIR = 1; }\n                else { BLINK(LED_J2); POS = LED2; DIR = 1; START = true; }\n                GOLPE_J1 = false;\n            } else if (POS == LED4) {\n                if (GOLPE_J2) { DIR = 0; }\n                else { BLINK(LED_J1); POS = LED2; DIR = 0; START = true; }\n                GOLPE_J2 = false;\n            }\n            EN_PARED = false;\n            gpio_clr_mask(MASCARA_LEDS_POS);\n            gpio_set_mask(1u &lt;&lt; POS);\n        }\n        return; // mientras dura la ventana no se mueve\n    }\n\n    // Mover pelota 1 paso\n    if (DIR &amp;&amp; POS &lt; LED4) POS++;\n    else if (!DIR &amp;&amp; POS &gt; LED0) POS--;\n\n    // Si lleg\u00f3 a pared, abrir ventana\n    if (POS == LED0 || POS == LED4) {\n        EN_PARED = true;\n        VENTANA_HASTA_US = tnow + REBOTE_US;\n    }\n\n    gpio_clr_mask(MASCARA_LEDS_POS);\n    gpio_set_mask(1u &lt;&lt; POS);\n}\n</code></pre>"},{"location":"Tareas/tarea6/#esquematico-de-conexion_1","title":"Esquematico de conexi\u00f3n","text":"<p> Figura 2.</p>"},{"location":"Tareas/tarea6/#video_1","title":"video","text":""},{"location":"Tareas/tarea6/#5-resultados-y-conclusiones","title":"5) Resultados y conclusiones","text":"<ul> <li> <p>Ej. 1: Cada LED parpadea a su frecuencia (intervalo configurado). El rearme acumulativo en software mantiene el ritmo sin sleep_ms().</p> </li> <li> <p>Ej. 2: BTN_MAS/BTN_MENOS cambian la velocidad al vuelo con antirrebote y realineo del pr\u00f3ximo tick.</p> </li> </ul>"},{"location":"Tareas/tarea7/","title":"\ud83d\udcd8 Tarea 7 \u2014 PWM","text":""},{"location":"Tareas/tarea7/#tarea-71-control-de-duty-cycle-motor-dc","title":"\ud83c\udfb5 Tarea 7.1 - Control de Duty Cycle \u2014 Motor DC","text":""},{"location":"Tareas/tarea7/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del subproyecto: Control PWM de motor DC con 3 velocidades  </li> <li>Autor: Carlos Ernesto Camacho Gonz\u00e1lez  </li> <li>Curso / Asignatura: Sistemas Embebidos  </li> <li>Fecha: 16/09/2025  </li> <li>Descripci\u00f3n breve: </li> <li>Controlar un motor DC mediante PWM variando el duty cycle.  </li> <li>Dos botones seleccionan tres velocidades predefinidas: baja, media y alta.  </li> <li>Se documentan valores de duty, circuito y c\u00f3digo.  </li> </ul> <p>Nota de seguridad: El microcontrolador no entrega corriente suficiente para un motor. Debe usarse un driver/puente H (p. ej., DRV8833, TB6612FNG o L298N) con fuente para el motor y GND com\u00fan con el micro.</p>"},{"location":"Tareas/tarea7/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Comprender c\u00f3mo el duty cycle del PWM regula la velocidad del motor DC.  </li> <li>Implementar una interfaz simple con dos botones para seleccionar tres velocidades.  </li> <li>Configurar correctamente el hardware PWM en RP2350/Pico 2 (frecuencia, <code>wrap</code>, <code>clkdiv</code>).  </li> </ul>"},{"location":"Tareas/tarea7/#3-conceptos-clave","title":"3) Conceptos clave","text":"<ul> <li>PWM (Modulaci\u00f3n por Ancho de Pulso): controla la tensi\u00f3n media aplicada al motor.  </li> <li>Frecuencia PWM: se usa 2 kHz (estable). Para evitar zumbido audible, se puede usar 20 kHz si el driver lo soporta.  </li> <li>Duty predefinido: </li> <li>Baja \u2248 30%, Media \u2248 60%, Alta \u2248 90%. Balance entre arranque, par y ruido.</li> </ul>"},{"location":"Tareas/tarea7/#4-codigo","title":"4) C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n\n#define MOTOR_PWM_PIN   0   // salida PWM al driver (IN1)\n#define BTN_UP          1   // subir velocidad\n#define BTN_DOWN        2   // bajar velocidad\n#define MOTOR_DIR_PIN   3   // direcci\u00f3n (IN2) fija = 1\n\n//  Configuraci\u00f3n PWM \n#define F_PWM_HZ 2000       // 2 kHz \n#define TOP      1023       // 10 bits de resoluci\u00f3n (0..1023)\n#define DEBOUNCE_MS 150\n\nint main(void) {\n    stdio_init_all();\n\n    // PWM en pin MOTOR_PWM_PIN\n    gpio_set_function(MOTOR_PWM_PIN, GPIO_FUNC_PWM);\n\n    // Direcci\u00f3n fija a 1 (un solo sentido)\n    gpio_init(MOTOR_DIR_PIN);\n    gpio_set_dir(MOTOR_DIR_PIN, GPIO_OUT);\n    gpio_put(MOTOR_DIR_PIN, 1);\n\n    // Botones con pull-up (activo-bajo)\n    gpio_init(BTN_UP);    gpio_set_dir(BTN_UP, GPIO_IN);    gpio_pull_up(BTN_UP);\n    gpio_init(BTN_DOWN);  gpio_set_dir(BTN_DOWN, GPIO_IN);  gpio_pull_up(BTN_DOWN);\n\n    // Configurar hardware PWM\n    uint slice = pwm_gpio_to_slice_num(MOTOR_PWM_PIN);\n    uint chan  = pwm_gpio_to_channel(MOTOR_PWM_PIN);\n\n    const float f_clk = 125000000.0f; // 125 MHz\n    const float clkdiv = f_clk / (F_PWM_HZ * (TOP + 1));\n    pwm_set_clkdiv(slice, clkdiv);\n    pwm_set_wrap(slice, TOP);\n\n    const uint16_t duty_levels[3] = {\n        (uint16_t)(0.30f * TOP),  // Baja  \n        (uint16_t)(0.60f * TOP),  // Media \n        (uint16_t)(0.90f * TOP)   // Alta  \n    };\n    int speed_level = 0;\n\n    // Iniciar PWM con velocidad \"Baja\"\n    pwm_set_chan_level(slice, chan, duty_levels[speed_level]);\n    pwm_set_enabled(slice, true);\n\n    while (true) {\n        // BTN_UP: siguiente velocidad\n        if (!gpio_get(BTN_UP)) {\n            if (speed_level &lt; 2) speed_level++;\n            pwm_set_chan_level(slice, chan, duty_levels[speed_level]);\n            sleep_ms(DEBOUNCE_MS);\n            // Espera a soltar para evitar autorepetici\u00f3n r\u00e1pida\n            while (!gpio_get(BTN_UP)) tight_loop_contents();\n        }\n\n        // BTN_DOWN: velocidad previa\n        if (!gpio_get(BTN_DOWN)) {\n            if (speed_level &gt; 0) speed_level--;\n            pwm_set_chan_level(slice, chan, duty_levels[speed_level]);\n            sleep_ms(DEBOUNCE_MS);\n            while (!gpio_get(BTN_DOWN)) tight_loop_contents();\n        }\n    }\n}\n</code></pre>"},{"location":"Tareas/tarea7/#5-video-de-demostracion","title":"5) Video de demostracion","text":""},{"location":"Tareas/tarea7/#video","title":"video","text":""},{"location":"Tareas/tarea7/#6-esquematico-de-conexion","title":"6) Esquem\u00e1tico de conexi\u00f3n","text":"<p> Figura 1. Conexi\u00f3n sugerida (referencial).</p>"},{"location":"Tareas/tarea7/#7-resultados-y-conclusiones","title":"7) Resultados y conclusiones","text":"<ul> <li> <p>Con 30/60/90% se observan claramente tres reg\u00edmenes de velocidad.</p> </li> <li> <p>Antirrebote bloqueante (150 ms).</p> </li> <li> <p>Usar driver dedicado y GND com\u00fan garantiza estabilidad y protege al microcontrolador.</p> </li> </ul>"},{"location":"Tareas/tarea7/#tarea-72-control-de-frecuencia-cancion-con-buzzer","title":"\ud83c\udfb5 Tarea 7.2 \u2014 Control de Frecuencia: Canci\u00f3n con Buzzer","text":""},{"location":"Tareas/tarea7/#1-resumen_1","title":"1) Resumen","text":"<ul> <li>Entregable: Programar un buzzer piezoel\u00e9ctrico para reproducir una melod\u00eda reconocible (intro de Pac-Man).  </li> <li>T\u00e9cnica: Variar la frecuencia del PWM para cada nota; duty = 50%.  </li> <li>Documentar: Tabla con notas/frecuencias/duraci\u00f3n y evidencia (audio/video).  </li> <li>Recomendaci\u00f3n: Los buzzer piezo suenan mejor ~532 Hz\u20134 kHz. Se usan notas en una octava que cae en ese rango.</li> </ul>"},{"location":"Tareas/tarea7/#2-codigo","title":"2) C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n#define BUZZER_PIN 0\n\n#define TOP 1023        // Resoluci\u00f3n (10 bits)\n#define TEMPO 190       // Tempo r\u00e1pido\n\n// Duraciones de nota\n#define NEGRA        (60000 / TEMPO)\n#define CORCHEA      (NEGRA / 2)\n#define SEMICORCHEA  (NEGRA / 4)\n\nint main() {\n    stdio_init_all();\n    gpio_set_function(BUZZER_PIN, GPIO_FUNC_PWM);\n\n    uint slice = pwm_gpio_to_slice_num(BUZZER_PIN);\n    uint chan  = pwm_gpio_to_channel(BUZZER_PIN);\n\n    pwm_set_wrap(slice, TOP);\n    pwm_set_chan_level(slice, chan, 0);   // empezar en silencio\n    pwm_set_enabled(slice, true);\n\n    // Pac-Man (intro + intermisi\u00f3n)\n    const float frecuencias[] = {\n        // Intro\n        987.77, 1479.98, 1244.51, 987.77, 1479.98, 1244.51, 0,\n        1046.50, 1567.98, 1318.51, 1046.50, 1567.98, 1318.51, 0,\n        987.77, 880.00, 783.99, 698.46, 622.25, 587.33, 0,\n        // Intermisi\u00f3n\n        783.99, 0, 880.00, 0, 987.77, 0, 783.99,\n        987.77, 0, 1046.50, 0, 1174.66, 0, 987.77,\n        1174.66, 0, 1244.51, 0, 1318.51, 0, 1174.66\n    };\n\n    const int duraciones[] = {\n        // Intro\n        CORCHEA, CORCHEA, CORCHEA, CORCHEA, CORCHEA, CORCHEA, CORCHEA,\n        CORCHEA, CORCHEA, CORCHEA, CORCHEA, CORCHEA, CORCHEA, CORCHEA,\n        SEMICORCHEA, SEMICORCHEA, SEMICORCHEA, SEMICORCHEA, SEMICORCHEA, NEGRA, NEGRA,\n        // Intermisi\u00f3n\n        CORCHEA, SEMICORCHEA, CORCHEA, SEMICORCHEA, CORCHEA, SEMICORCHEA, NEGRA,\n        CORCHEA, SEMICORCHEA, CORCHEA, SEMICORCHEA, CORCHEA, SEMICORCHEA, NEGRA,\n        CORCHEA, SEMICORCHEA, CORCHEA, SEMICORCHEA, CORCHEA, SEMICORCHEA, NEGRA\n    };\n\n    const int num_notas = (int)(sizeof(frecuencias) / sizeof(frecuencias[0]));\n\n    while (true) {\n        for (int i = 0; i &lt; num_notas; i++) {\n            if (frecuencias[i] &gt; 0.0f) {\n                // Para RP2350 el sysclk t\u00edpico es 150 MHz; si usas RP2040 usa 125 MHz\n                const float f_clk = 150000000.0f;\n                const float div = f_clk / (frecuencias[i] * (TOP + 1));\n                pwm_set_clkdiv(slice, div);\n                pwm_set_chan_level(slice, chan, TOP / 2); // 50% duty\n            } else {\n                // silencio (pausa)\n                pwm_set_chan_level(slice, chan, 0);\n            }\n            sleep_ms(duraciones[i]);\n        }\n        // Pausa entre repeticiones\n        pwm_set_chan_level(slice, chan, 0);\n        sleep_ms(2000);\n    }\n}\n</code></pre>"},{"location":"Tareas/tarea7/#3-tabla-de-notas-usadas-referencia","title":"3) Tabla de notas usadas (referencia)","text":"Nota (aprox) Frec. (Hz) Comentario B5 987.77 Inicio caracter\u00edstico F\u266f6 1479.98 Agudo brillante D\u266f6 / E\u266d6 1244.51 C6 1046.50 G6 1567.98 E6 1318.51 A5 880.00 G5 783.99 F5 698.46 D\u266f5 / E\u266d5 622.25 D5 587.33 D6 1174.66 <p>Tip: si escuchas distorsi\u00f3n, sube la frecuencia PWM manteniendo el duty 50%.</p>"},{"location":"Tareas/tarea7/#4-evidencias","title":"4) Evidencias","text":""},{"location":"Tareas/tarea7/#video-audio","title":"Video / Audio","text":""},{"location":"Tareas/tarea7/#5-esquematico-de-conexion","title":"5) Esquem\u00e1tico de conexi\u00f3n","text":"<p> Figura 1. Conexi\u00f3n sugerida (referencial).</p>"},{"location":"Tareas/tarea7/#6-conclusiones-tarea-72","title":"6) Conclusiones (Tarea 7.2)","text":"<ul> <li>La melod\u00eda se logra variando la frecuencia del PWM con duty fijo (50%).  </li> <li>Mantener el rango ~532 Hz\u20134 kHz asegura buena respuesta del buzzer piezo.  </li> <li>Ajustar clkdiv en tiempo real permite notas afinadas sin bloquear otros procesos.</li> </ul>"},{"location":"Tareas/tarea7/#tarea-73-generacion-de-senales-senoidal-de-60-hz-con-pwm-filtro-rc","title":"\ud83d\udee0\ufe0f Tarea 7.3 \u2014 Generaci\u00f3n de Se\u00f1ales: Senoidal de 60 Hz con PWM + Filtro RC","text":""},{"location":"Tareas/tarea7/#1-resumen_2","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Se\u00f1al senoidal con PWM y filtrado RC  </li> <li>Autor: Carlos Ernesto Camacho Gonz\u00e1lez  </li> <li>Curso / Asignatura: Sistemas Embebidos  </li> <li>Fecha: 16/09/2025  </li> <li>Descripci\u00f3n breve: </li> <li>Generar una se\u00f1al sinusoidal de 60 Hz aproximada mediante PWM variando el duty cycle con una tabla seno.  </li> <li>Filtrar la se\u00f1al usando un filtro RC pasabajos para obtener una forma senoidal limpia en el osciloscopio.  </li> <li>Documentar capturas de PWM sin filtrar y se\u00f1al filtrada.</li> </ul>"},{"location":"Tareas/tarea7/#2-objetivos_1","title":"2) Objetivos","text":"<ul> <li>Implementar una tabla seno para modular el duty cycle del PWM.  </li> <li>Usar un filtro RC que aten\u00fae las componentes de alta frecuencia y deje pasar los 60 Hz.  </li> <li>Verificar la se\u00f1al en osciloscopio antes y despu\u00e9s del filtro.</li> </ul>"},{"location":"Tareas/tarea7/#3-conceptos-clave_1","title":"3) Conceptos clave","text":""},{"location":"Tareas/tarea7/#senal-senoidal-con-pwm","title":"Se\u00f1al senoidal con PWM","text":"<p>El microcontrolador genera una onda PWM cuyo duty cycle sigue la forma de una tabla seno. Tras el filtrado RC, se obtiene una onda anal\u00f3gica.</p>"},{"location":"Tareas/tarea7/#4-codigo_1","title":"4) C\u00f3digo","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n#define SENAL 0          // Pin GPIO de salida\n#define TOP 1023         // Resoluci\u00f3n del PWM (10 bits)\n#define FREQ 60          // Frecuencia de la se\u00f1al senoidal deseada (Hz)\n#define TAMANO_SENO 100  // N\u00famero de puntos en la tabla seno\n\n// Tabla seno (se llenar\u00e1 en tiempo de ejecuci\u00f3n)\nuint16_t TABLA_SENO[TAMANO_SENO];\n\nint main() {\n    stdio_init_all();\n\n    // Llenar tabla seno con valores escalados a [0, TOP]\n    for (uint8_t i = 0; i &lt; TAMANO_SENO; i++) {\n        double RAD = (2 * M_PI * i) / TAMANO_SENO;\n        double VAL = (sin(RAD) + 1.0) / 2.0;  // normalizada a 0\u20131\n        TABLA_SENO[i] = (uint16_t)(VAL * TOP);\n    }\n\n    // Configurar pin PWM\n    gpio_set_function(SENAL, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(SENAL);\n    uint chan = pwm_gpio_to_channel(SENAL);\n\n    pwm_set_wrap(slice, TOP);\n    pwm_set_chan_level(slice, chan, 0);\n    pwm_set_enabled(slice, true);\n\n    // Calcular frecuencia de actualizaci\u00f3n de la LUT\n    double RATE = FREQ * TAMANO_SENO;      // actualizaciones/segundo\n    uint32_t delay_us = 1000000.0 / RATE;  // periodo en \u00b5s\n\n    int INDEX = 0;\n    while (true) {\n        pwm_set_chan_level(slice, chan, TABLA_SENO[INDEX]);\n\n        INDEX++;\n        if (INDEX &gt;= TAMANO_SENO) INDEX = 0;\n\n        sleep_us(delay_us);  // Ajusta la frecuencia\n    }\n}\n</code></pre>"},{"location":"Tareas/tarea7/#5-evidencias","title":"5) Evidencias","text":""},{"location":"Tareas/tarea7/#osciloscopio","title":"Osciloscopio","text":"<ul> <li>Antes del filtro (PWM): se\u00f1al rectangular con duty variable.  </li> <li>Despu\u00e9s del filtro RC: onda senoidal de 60 Hz m\u00e1s limpia.  </li> </ul> <p> Figura 1. Se\u00f1al PWM cruda. </p> <p> Figura 2. Se\u00f1al senoidal tras el filtro RC. </p>"},{"location":"Tareas/tarea7/#6-resultados-y-conclusiones","title":"6) Resultados y conclusiones","text":"<ul> <li>El PWM con duty modulado por tabla seno reproduce correctamente la forma senoidal.  </li> <li>El filtro RC aten\u00faa los arm\u00f3nicos de alta frecuencia y deja pasar los 60 Hz.  </li> <li>Ajustar R y C permite modificar la frecuencia de corte para un mejor compromiso entre limpieza de se\u00f1al y amplitud.  </li> <li>Se logr\u00f3 una se\u00f1al anal\u00f3gica senoidal a partir de un pin digital del microcontrolador.</li> </ul>"}]}