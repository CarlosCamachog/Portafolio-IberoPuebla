{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Portafolio Ibero Puebla","text":"<p>\u00a1Bienvenido a mi portafolio de evidencias! Aqu\u00ed encontrar\u00e1s tareas, proyectos y recursos de Mecatr\u00f3nica.</p>"},{"location":"#sobre-mi","title":"Sobre m\u00ed","text":"<p>Soy Carlos Ernesto Camacho Gonz\u00e1lez, estudiante de Mecatr\u00f3nica en Ibero Puebla.  </p>"},{"location":"#contenido","title":"Contenido","text":"<ul> <li>Tareas </li> <li>Proyecto de ingenier\u00eda V </li> </ul>"},{"location":"#contacto","title":"Contacto","text":"<ul> <li>Correo: 198168@iberopuebla.mx </li> <li>GitHub: https://github.com/CarlosCamachog</li> </ul>"},{"location":"comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p>[x] Hecho</p> </li> <li>[ ] Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea1/","title":"\ud83d\udcd8 Activity 1 \u2014 FreeRTOS Tasks and Priorities","text":"<p>Identification, analysis, and design of logical tasks using FreeRTOS concepts.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea1/#overview","title":") Overview","text":"<ul> <li>Topic: Task identification, priorities, and system design with FreeRTOS</li> <li>Autor: Carlos Ernesto Camacho Gonz\u00e1lez</li> <li>Curso / Asignatura: Sistemas Embebidos  </li> </ul>"},{"location":"Sistemas%20Embebidos%20II/tarea1/#1-exercise-1-identify-logical-tasks","title":"1) Exercise 1 \u2014 Identify Logical Tasks","text":"Task Trigger (Time / Event) Periodic / Event-Based Reads a temperature sensor every 50 ms 50 ms timer Periodic Sends sensor data via Wi-Fi every 2 s 2 s timer Periodic Monitors an emergency button Button press Event-Based Blinks a status LED at 1 Hz Timer (1 s) Periodic Stores error messages when failures occur Error event Event-Based"},{"location":"Sistemas%20Embebidos%20II/tarea1/#2-exercise-2-task-characteristics","title":"2) Exercise 2 \u2014 Task Characteristics","text":"Is it time-critical? (Yes / No) Can it block safely? (Yes / No) What happens if this task is delayed? No Yes It depends on the system; however, in general, the sensor would read the information at the end. No No If it takes a while, it would send the data, but if it gets blocked, it could affect communication. Yes No It would cause an accident. No Yes The LED just looks weird. No Yes Only data is lost."},{"location":"Sistemas%20Embebidos%20II/tarea1/#3-exercise-3-priority-reasoning","title":"3) Exercise 3 \u2014 Priority Reasoning","text":"Task Name Priority (H / M / L) Justification Temperature Medium It is important for system operation, but small delays are acceptable. Wi-Fi Medium Communication is necessary, but short delays do not compromise safety. Emergency button High It is safety-critical and must be handled immediately. LED Low It is only visual feedback and not functionally critical. Error messages Low Logging is useful but not urgent compared to control or safety tasks."},{"location":"Sistemas%20Embebidos%20II/tarea1/#4-exercise-4-design-judgment-trick-question","title":"4) Exercise 4 \u2014 Design Judgment (Trick Question)","text":"<p>Emergency button monitoring</p> <p>Explanation (2\u20133 sentences): Emergency button monitoring should not necessarily be implemented as a FreeRTOS task because it is time-critical and must react immediately. According to the document, a delay could cause an accident, so handling it as a hardware interrupt is more appropriate. Interrupts provide faster response than polling inside a task.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea1/#5-exercise-51-identify-hidden-tasks","title":"5) Exercise 5.1 \u2014 Identify Hidden Tasks","text":"Hidden Task Trigger (Time / Event) Why it should be a Task Read temperature sensor Repeated in the loop (time-based) It needs to run regularly, and its timing should not depend on other code. Emergency button check Button press (event) It is very important and must react immediately to avoid accidents. Send data over Wi-Fi Every 2000 ms (time-based) This operation can block for a long time and delay other actions. Status LED blinking Every 1 second (1 Hz) The LED needs stable timing to blink correctly. Loop delay Every loop iteration The delay controls execution speed but blocks the whole program."},{"location":"Sistemas%20Embebidos%20II/tarea1/#52-exercise-52-blocking-analysis","title":"5.2) Exercise 5.2 \u2014 Blocking Analysis","text":"<p>1) Which function can block the CPU? - <code>send_data_over_wifi()</code> (it may block for 100\u2013300 ms)</p> <p>2) What other behaviors are affected while it blocks? - The program cannot check the emergency button during that time. - The LED blink becomes irregular (not a clean 1 Hz). - The temperature reading becomes delayed and not consistent.</p> <p>3) Which hidden task is most at risk because of this blocking? - Emergency button handling, because it must react immediately and blocking can delay the shutdown.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea1/#53-exercise-53-rtos-refactoring-thought-experiment","title":"5.3) Exercise 5.3 \u2014 RTOS Refactoring Thought Experiment","text":""},{"location":"Sistemas%20Embebidos%20II/tarea1/#which-hidden-tasks-should-become-freertos-tasks","title":"Which hidden task(s) should become FreeRTOS tasks?","text":"<p>The temperature reading should be a task because it needs to run periodically and with stable timing. The Wi-Fi data transmission should also be a task because it can block the CPU for a long time. The LED blinking can be a low-priority task because it runs periodically and is not critical.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea1/#which-behaviors-should-be-handled-using-an-interrupt","title":"Which behavior(s) should be handled using an interrupt?","text":"<p>The emergency button should be handled using an interrupt because it must react immediately. Using an interrupt avoids delays caused by other tasks.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea1/#which-task-should-have-the-highest-priority-and-why","title":"Which task should have the highest priority, and why?","text":"<p>The emergency or safety task should have the highest priority because it is safety-critical. If it is delayed, it could cause an accident.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea2/","title":"Session 2 \u2014 RTOS Basics: Tasks, Queues, and Mutex","text":"<p>Implement basic FreeRTOS multitasking concepts in ESP-IDF using tasks, queues, and mutex protection.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#1-activity-goals","title":"1) Activity Goals","text":"<ul> <li>Implement multiple FreeRTOS tasks running concurrently.</li> <li>Validate task scheduling using <code>vTaskDelay()</code>.</li> <li>Pass data between tasks using a queue (producer/consumer).</li> <li>Demonstrate a race condition and fix it using a mutex.</li> <li>Document evidence with console logs, screenshots, and videos.</li> </ul>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#2-materials-setup","title":"2) Materials &amp; Setup","text":""},{"location":"Sistemas%20Embebidos%20II/tarea2/#bom-bill-of-materials","title":"BOM (Bill of Materials)","text":"# Item Qty Link/Source Cost (MXN) Notes 1 ESP32 Board 1 Local Store / Amazon / MercadoLibre 365 Main development board 2 LED 1 Local electronics store 3 Status LED connected to GPIO 8"},{"location":"Sistemas%20Embebidos%20II/tarea2/#toolssoftware","title":"Tools/Software","text":"<ul> <li>Framework: ESP-IDF + FreeRTOS  </li> </ul>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#lab-1-two-tasks-delays-and-priorities","title":"Lab 1 \u2014 Two Tasks, Delays, and Priorities","text":"<p>Run two tasks at the same time: one blinking an LED and one printing a message.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#3-procedure-what-you-did","title":"3) Procedure (what you did)","text":"<ol> <li>Created two FreeRTOS tasks (<code>blink_task</code> and <code>hello_task</code>).</li> <li>Verified LED blinking every 300 ms.</li> <li>Verified console prints every 1 second.</li> <li>Modified task priority.</li> <li>Removed delay to observe starvation behavior.</li> </ol>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#4-data-tests-evidence","title":"4) Data, Tests &amp; Evidence","text":""},{"location":"Sistemas%20Embebidos%20II/tarea2/#evidence-console-output","title":"Evidence (Console Output)","text":"<p> Figure 1. Console output showing Lab 1 execution.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#evidence-led-blinking","title":"Evidence (LED Blinking)","text":"<p>Video 1. LED blinking behavior for Lab 1.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#6-code","title":"6) Code","text":""},{"location":"Sistemas%20Embebidos%20II/tarea2/#code-lab-1","title":"Code (Lab 1)","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"driver/gpio.h\"\n#include \"esp_log.h\"\n\n#define LED_GPIO GPIO_NUM_8   // CHANGE for your board\n\nstatic const char *TAG = \"LAB1\";\n\nstatic void blink_task(void *pvParameters)\n{\n    gpio_reset_pin(LED_GPIO);\n    gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);\n\n    while (1) {\n        gpio_set_level(LED_GPIO, 1);\n        vTaskDelay(pdMS_TO_TICKS(300));\n        gpio_set_level(LED_GPIO, 0);\n        vTaskDelay(pdMS_TO_TICKS(300));\n    }\n}\n\nstatic void hello_task(void *pvParameters)\n{\n    int n = 0;\n    while (1) {\n        ESP_LOGI(TAG, \"hello_task says hi, n=%d\", n++);\n        vTaskDelay(pdMS_TO_TICKS(1000));\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 1 (two tasks)\");\n\n    xTaskCreate(blink_task, \"blink_task\", 2048, NULL, 5, NULL);\n    xTaskCreate(hello_task, \"hello_task\", 2048, NULL, 5, NULL);\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#5-analysis-exercises","title":"5) Analysis (Exercises)","text":""},{"location":"Sistemas%20Embebidos%20II/tarea2/#exercise-1-priority-experiment","title":"Exercise 1 \u2014 Priority Experiment","text":"<p>Change <code>hello_task</code> priority from 5 to 2:</p> <pre><code>xTaskCreate(hello_task, \"hello_task\", 2048, NULL, 2, NULL);\n</code></pre>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#does-behavior-change-why-might-it-or-might-it-not","title":"Does behavior change? Why might it (or might it not)?","text":"<p>NO, because it doesn\u2019t affect the blink time of the LED. Both tasks use <code>vTaskDelay()</code>, so they block and allow the CPU to run other tasks.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#evidence","title":"Evidence","text":"<p> Figure 2. Priority experiment output: hello_task priority changed from 5 to 2.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#exercise-2-starvation-demo","title":"Exercise 2 \u2014 Starvation Demo","text":"<p>Temporarily remove this line from <code>hello_task</code>:</p> <pre><code>vTaskDelay(pdMS_TO_TICKS(1000));\n</code></pre>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#what-happens-to-blinking","title":"What happens to blinking?","text":"<p>The LED blinking looks almost the same or does not show a clear difference. This is because FreeRTOS still schedules <code>blink_task</code> even if <code>hello_task</code> has no delay. However, <code>hello_task</code> uses much more CPU and can reduce system responsiveness.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#evidence_1","title":"Evidence","text":"<p>Video 2. Starvation experiment: hello_task delay removed to observe CPU usage effects.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#exercise-3-put-the-delay-back-and-explain-in-one-sentence-why-blocking-helps","title":"Exercise 3 \u2014 Put the delay back and explain in one sentence why blocking helps","text":"<p>Blocking helps because <code>vTaskDelay()</code> puts the task in a blocked state and frees the CPU so other tasks can run.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#lab-2-queue-producer-consumer","title":"Lab 2 \u2014 Queue (Producer / Consumer)","text":"<p>Send integers from a producer task to a consumer task using a FreeRTOS queue.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#3-procedure-what-you-did_1","title":"3) Procedure (what you did)","text":"<ol> <li>Created a queue using <code>xQueueCreate</code>.</li> <li>Implemented a producer task to send integers to the queue.</li> <li>Implemented a consumer task to receive integers from the queue.</li> <li>Modified producer speed.</li> <li>Increased queue length.</li> <li>Made the consumer slower.</li> </ol>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#4-data-tests-evidence_1","title":"4) Data, Tests &amp; Evidence","text":""},{"location":"Sistemas%20Embebidos%20II/tarea2/#evidence_2","title":"Evidence","text":"<p> Figure 3. Console output showing producer_task and consumer_task using a queue.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#6-code_1","title":"6) Code","text":""},{"location":"Sistemas%20Embebidos%20II/tarea2/#code-lab-2","title":"Code (Lab 2)","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/queue.h\"\n#include \"esp_log.h\"\n\nstatic const char *TAG = \"LAB2\";\nstatic QueueHandle_t q_numbers;\n\nstatic void producer_task(void *pvParameters)\n{\n    int value = 0;\n\n    while (1) {\n        value++;\n\n        // Send to queue; wait up to 50ms if full\n        if (xQueueSend(q_numbers, &amp;value, pdMS_TO_TICKS(50)) == pdPASS) {\n            ESP_LOGI(TAG, \"Produced %d\", value);\n        } else {\n            ESP_LOGW(TAG, \"Queue full, dropped %d\", value);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(200));\n    }\n}\n\nstatic void consumer_task(void *pvParameters)\n{\n    int rx = 0;\n\n    while (1) {\n        // Wait up to 1000ms for data\n        if (xQueueReceive(q_numbers, &amp;rx, pdMS_TO_TICKS(1000)) == pdPASS) {\n            ESP_LOGI(TAG, \"Consumed %d\", rx);\n        } else {\n            ESP_LOGW(TAG, \"No data in 1s\");\n        }\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 2 (queue)\");\n\n    q_numbers = xQueueCreate(5, sizeof(int)); // length 5\n    if (q_numbers == NULL) {\n        ESP_LOGE(TAG, \"Queue create failed\");\n        return;\n    }\n\n    xTaskCreate(producer_task, \"producer_task\", 2048, NULL, 5, NULL);\n    xTaskCreate(consumer_task, \"consumer_task\", 2048, NULL, 5, NULL);\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#5-analysis-exercises_1","title":"5) Analysis (Exercises)","text":""},{"location":"Sistemas%20Embebidos%20II/tarea2/#exercise-1-make-the-producer-faster-change-producer-delay-200ms-20ms","title":"Exercise 1 \u2014 Make the producer faster: change producer delay 200ms \u2192 20ms","text":"<pre><code>vTaskDelay(pdMS_TO_TICKS(20));\n</code></pre>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#exercise-2-when-do-you-see-queue-full","title":"Exercise 2 \u2014 When do you see \u201cQueue full\u201d?","text":"<p>Never. This happens because the consumer receives data fast enough to keep the queue from filling, so the producer is always able to send values successfully.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#evidence_3","title":"Evidence","text":"<p>Video 3. Producer speed increased (20 ms delay), showing that the queue does not overflow.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#exercise-3-increase-the-queue-length-5-20","title":"Exercise 3 \u2014 Increase the queue length 5 \u2192 20","text":"<pre><code>q_numbers = xQueueCreate(20, sizeof(int));\n</code></pre>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#exercise-4-what-changes","title":"Exercise 4 \u2014 What changes?","text":"<p>The queue can store more values, so \"Queue full\" happens less often or takes longer to appear.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#evidence_4","title":"Evidence","text":"<p>Video 4. Queue length increased to 20, allowing more buffering before overflow.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#exercise-5-make-the-consumer-slow-after-a-successful-receive-add","title":"Exercise 5 \u2014 Make the consumer \u201cslow\u201d: after a successful receive, add:","text":"<pre><code>vTaskDelay(pdMS_TO_TICKS(300));\n</code></pre>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#exercise-6-what-pattern-is-happening-now-buffering-backlog","title":"Exercise 6 \u2014 What pattern is happening now (buffering / backlog)?","text":"<p>The queue stores values temporarily, then it fills up and the producer starts dropping values because there is no more space.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#evidence_5","title":"Evidence","text":"<p>Video 5. Consumer slowed down (300 ms delay), showing buffering and possible backlog in the queue.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#lab-3-mutex-protect-a-shared-resource","title":"Lab 3 \u2014 Mutex: Protect a Shared Resource","text":"<p>Demonstrate a race condition with a shared counter and fix it using a mutex.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#3-procedure-what-you-did_2","title":"3) Procedure (what you did)","text":"<ol> <li>Implemented two tasks that increment a shared counter.</li> <li>Ran the program without mutex to observe race conditions.</li> <li>Added a mutex to protect the shared counter.</li> <li>Removed the mutex again to confirm weird behavior.</li> <li>Changed task priorities and observed scheduling effects.</li> </ol>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#6-code_2","title":"6) Code","text":""},{"location":"Sistemas%20Embebidos%20II/tarea2/#part-a-race-demo-no-mutex","title":"Part A \u2014 Race demo (no mutex)","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"esp_log.h\"\n\nstatic const char *TAG = \"LAB3A\";\n\nstatic volatile int shared_counter = 0;\n\nstatic void increment_task(void *pvParameters)\n{\n    const char *name = (const char *)pvParameters;\n\n    while (1) {\n        // NOT safe: read-modify-write without protection\n        int local = shared_counter;\n        local++;\n        shared_counter = local;\n\n        if ((shared_counter % 1000) == 0) {\n            ESP_LOGI(TAG, \"%s sees counter=%d\", name, shared_counter);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(1));\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 3A (race demo)\");\n\n    xTaskCreate(increment_task, \"incA\", 2048, \"TaskA\", 5, NULL);\n    xTaskCreate(increment_task, \"incB\", 2048, \"TaskB\", 5, NULL);\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#5-analysis-exercises_2","title":"5) Analysis (Exercises)","text":""},{"location":"Sistemas%20Embebidos%20II/tarea2/#part-a-race-demo-no-mutex_1","title":"Part A \u2014 Race demo (no mutex)","text":""},{"location":"Sistemas%20Embebidos%20II/tarea2/#question","title":"Question","text":"<p>Why can the counter be wrong?</p>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#answer","title":"Answer","text":"<p>The counter may be faulty because both tasks read the same value and overwrite it, losing increments.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#evidence_6","title":"Evidence","text":"<p> Figure 4. Race condition evidence: shared_counter increment without mutex protection.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#6-code_3","title":"6) Code","text":""},{"location":"Sistemas%20Embebidos%20II/tarea2/#part-b-fix-with-a-mutex","title":"Part B \u2014 Fix with a mutex","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/semphr.h\"\n#include \"esp_log.h\"\n\nstatic const char *TAG = \"LAB3B\";\n\nstatic volatile int shared_counter = 0;\nstatic SemaphoreHandle_t counter_mutex;\n\nstatic void increment_task(void *pvParameters)\n{\n    const char *name = (const char *)pvParameters;\n\n    while (1) {\n        xSemaphoreTake(counter_mutex, portMAX_DELAY);\n\n        int local = shared_counter;\n        local++;\n        shared_counter = local;\n\n        xSemaphoreGive(counter_mutex);\n\n        if ((shared_counter % 1000) == 0) {\n            ESP_LOGI(TAG, \"%s sees counter=%d\", name, shared_counter);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(1));\n    }\n}\n\nvoid app_main(void)\n{\n    ESP_LOGI(TAG, \"Starting Lab 3B (mutex fix)\");\n\n    counter_mutex = xSemaphoreCreateMutex();\n    if (counter_mutex == NULL) {\n        ESP_LOGE(TAG, \"Mutex create failed\");\n        return;\n    }\n\n    xTaskCreate(increment_task, \"incA\", 2048, \"TaskA\", 5, NULL);\n    xTaskCreate(increment_task, \"incB\", 2048, \"TaskB\", 5, NULL);\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#exercise-1-remove-the-mutex-again","title":"Exercise 1 \u2014 Remove the mutex again","text":""},{"location":"Sistemas%20Embebidos%20II/tarea2/#question_1","title":"Question","text":"<p>Do you ever see weird behavior?</p>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#answer_1","title":"Answer","text":"<p>Yes, sometimes the counter increases slower than expected or skips values.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#evidence_7","title":"Evidence","text":"<p> Figure 5. Evidence after removing the mutex: counter behavior becomes inconsistent.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#exercise-2-change-priorities-taska-6-taskb-4","title":"Exercise 2 \u2014 Change priorities (TaskA = 6, TaskB = 4)","text":""},{"location":"Sistemas%20Embebidos%20II/tarea2/#question_2","title":"Question","text":"<p>What do you expect and why?</p>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#answer_2","title":"Answer","text":"<p>TaskA (priority 6) will run more often than TaskB (priority 4). TaskA will usually print more messages because it gets CPU time first when both tasks are ready.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#evidence_8","title":"Evidence","text":"<p> Figure 6. Priority experiment: TaskA (priority 6) runs more often than TaskB (priority 4).</p>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#exercise-3-one-sentence","title":"Exercise 3 \u2014 One sentence","text":""},{"location":"Sistemas%20Embebidos%20II/tarea2/#question_3","title":"Question","text":"<p>In one sentence: what does a mutex \u201cguarantee\u201d?</p>"},{"location":"Sistemas%20Embebidos%20II/tarea2/#answer_3","title":"Answer","text":"<p>A mutex guarantees that only one task at a time can access the shared resource, preventing race conditions.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea3/","title":"Session 3 \u2014 FreeRTOS Tasks, Queues, and Mutex","text":"<p>Implement multiple FreeRTOS tasks in ESP-IDF, including heartbeat, alive logs, queue communication, mutex protection, and error logging.</p>"},{"location":"Sistemas%20Embebidos%20II/tarea3/#1-activity-goals","title":"1) Activity Goals","text":"<ul> <li>Implement Task 1 (Heartbeat LED)</li> <li>Implement Task 2 (Alive task every 2 seconds)</li> <li>Implement Task 3 (Queue Struct Send)</li> <li>Implement Task 4 (Queue Struct Receive)</li> <li>Implement Task 5 (Mutex protected button reading)</li> <li>Implement Task 6 (Second mutex protected button task)</li> <li>Implement Task 7 (Error logging system)</li> </ul>"},{"location":"Sistemas%20Embebidos%20II/tarea3/#2-materials-setup","title":"2) Materials &amp; Setup","text":""},{"location":"Sistemas%20Embebidos%20II/tarea3/#bom-bill-of-materials","title":"BOM (Bill of Materials)","text":"# Item Qty Link/Source Cost (MXN) Notes 1 ESP32 Board 1 Local Store / Amazon / MercadoLibre 365 Main development board 2 LED 1 Local electronics store 3 Status LED connected to GPIO 8 3 Push Button 1 Local electronics store / Amazon / MercadoLibre 1.70-3.60 Button connected to GPIO ___"},{"location":"Sistemas%20Embebidos%20II/tarea3/#toolssoftware","title":"Tools/Software","text":"<ul> <li>Framework: ESP-IDF + FreeRTOS  </li> </ul>"},{"location":"Sistemas%20Embebidos%20II/tarea3/#3-procedure-what-you-did","title":"3) Procedure (what you did)","text":"<ol> <li>Created FreeRTOS tasks for heartbeat and alive monitoring.</li> <li>Implemented queue producer/consumer communication with structs.</li> <li>Implemented mutex protection for shared resources.</li> <li>Implemented error logging system.</li> <li>Verified correct execution using serial monitor output and LED behavior.</li> </ol>"},{"location":"Sistemas%20Embebidos%20II/tarea3/#4-evidence-console-photos-videos","title":"4) Evidence (Console, Photos, Videos)","text":""},{"location":"Sistemas%20Embebidos%20II/tarea3/#task-without-error-logging-system","title":"Task without error logging system","text":""},{"location":"Sistemas%20Embebidos%20II/tarea3/#task-with-error-logging-system","title":"Task with error logging system","text":""},{"location":"Sistemas%20Embebidos%20II/tarea3/#5-code","title":"5) Code","text":""},{"location":"Sistemas%20Embebidos%20II/tarea3/#task-with-error-logging-system_1","title":"Task with error logging system","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/semphr.h\"\n#include \"driver/gpio.h\"\n#include \"freertos/queue.h\"\n#include \"esp_log.h\"\n\n\n#define LED_GPIO GPIO_NUM_8   // CHANGE for your board\n#define BUTTON_GPIO GPIO_NUM_10 // CHANGE for your board\n\nstatic const char *TAG = \"HearbeatApp\";\nvolatile bool error[7] = {false, false, false, false, false, false};\n\nstatic QueueHandle_t q_numbers;\nstatic QueueHandle_t q_errors;\nstatic SemaphoreHandle_t shared_counter;\n\nstruct DataPacket {\n    int id;\n    float value;\n};\n\nstruct ErrorStatus {\n    int task_id;\n    bool error_state;\n};\n\nstatic void button_task1(void *pvParameters)\n{\n    gpio_reset_pin(BUTTON_GPIO);\n    gpio_set_direction(BUTTON_GPIO, GPIO_MODE_INPUT);\n    gpio_set_pull_mode(BUTTON_GPIO, GPIO_PULLUP_ONLY);\n    float pressed_time = 0.0f;\n\n    while (1) {\n        bool current_state = !gpio_get_level(BUTTON_GPIO); // Active low\n        if (current_state) {\n            pressed_time += 0.05f; // Simulating time increment\n        } \n        else if (!current_state &amp;&amp; pressed_time &gt; 0.0f) {\n            ESP_LOGI(TAG, \"Button 1 pressed for %f seconds\", pressed_time);\n\n            struct ErrorStatus status = {5, true};\n            xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n\n            pressed_time = 0.0f;\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(50)); // Polling delay\n    }\n}\n\nstatic void button_task2(void *pvParameters)\n{\n    gpio_reset_pin(BUTTON_GPIO);\n    gpio_set_direction(BUTTON_GPIO, GPIO_MODE_INPUT);\n    gpio_set_pull_mode(BUTTON_GPIO, GPIO_PULLUP_ONLY);\n    float pressed_time = 0.0f;\n\n    while (1) {\n        bool current_state = !gpio_get_level(BUTTON_GPIO); // Active low\n        if (current_state) {\n            pressed_time += 0.05f; // Simulating time increment\n        }\n        else if (!current_state &amp;&amp; pressed_time &gt; 0.0f) {\n            ESP_LOGI(TAG, \"Button 2 pressed for %f seconds\", pressed_time);\n\n            struct ErrorStatus status = {6, true};\n            xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n\n            pressed_time = 0.0f;\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(50)); // Polling delay\n    }\n}\n\nstatic void producer_task(void *pvParameters)\n{\n    struct DataPacket packet;\n    packet.id = 0;\n    packet.value = 0.0f;\n    while (1) {\n       packet.id=rand()%1000;\n       packet.value=(float)(rand()%1000)/10.0f;\n\n        // Send to queue; wait up to 50ms if full\n        if (xQueueSend(q_numbers, &amp;packet, pdMS_TO_TICKS(50)) == pdPASS) {\n            struct ErrorStatus status = {3, true};\n            xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n            ESP_LOGI(TAG, \"Produced %d with value %f\", packet.id, packet.value);\n        } else {\n            struct ErrorStatus status = {3, true};\n            xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n            ESP_LOGW(TAG, \"Queue full, dropped %d with value %f\", packet.id, packet.value);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(200));\n    }\n}\n\nstatic void consumer_task(void *pvParameters)\n{\n     struct DataPacket packet_recv;\n\n    while (1) {\n        // Wait up to 1000ms for data\n        if (xQueueReceive(q_numbers, &amp;packet_recv, pdMS_TO_TICKS(1500)) == pdPASS) {\n            struct ErrorStatus status = {4, true};\n            xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n            ESP_LOGI(TAG, \"Consumed %d with value %f\", packet_recv.id, packet_recv.value);\n        } else {\n            struct ErrorStatus status = {4, true};\n            xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n            ESP_LOGW(TAG, \"No data in 1s\");\n        }\n    }\n}\n\nstatic void heartbeat_task(void *pvParameters)\n{\n    while (1) {\n        struct ErrorStatus status = {0, true};\n        xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n        ESP_LOGI(TAG, \"alive\");\n        vTaskDelay(pdMS_TO_TICKS(2000));\n    }\n}\n\nstatic void hearbeatLED_task(void *pvParameters)\n{\n    gpio_reset_pin(LED_GPIO);\n    gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);\n\n    while (1) {\n        struct ErrorStatus status = {2, true};\n        xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n        gpio_set_level(LED_GPIO, 1);\n        vTaskDelay(pdMS_TO_TICKS(300));\n        gpio_set_level(LED_GPIO, 0);\n        vTaskDelay(pdMS_TO_TICKS(300));\n    }\n}\n\nstatic void bpm_task(void *pvParameters){\n    while (1) {\n        struct ErrorStatus status = {1, true};\n        xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n        printf(\"BPM: %d\\n\", rand()%40 + 60);\n        vTaskDelay(pdMS_TO_TICKS(500));\n    }\n}\n\nstatic void error_task(void *pvParameters)\n{\n    struct ErrorStatus status;\n    while (1) {\n        if (xQueueReceive(q_errors, &amp;status, pdMS_TO_TICKS(100)) == pdPASS) {\n            if (xSemaphoreTake(shared_counter, pdMS_TO_TICKS(10)) == pdTRUE) {\n                error[status.task_id] = status.error_state;\n                if (status.error_state) {\n                    ESP_LOGE(TAG, \"Error task %d\", status.task_id);\n                }\n                xSemaphoreGive(shared_counter);\n            }\n        }\n    }\n}\n\nvoid app_main(void)\n{\n    // Create mutex for shared resources\n    shared_counter = xSemaphoreCreateMutex();\n    if (shared_counter == NULL) {\n        ESP_LOGE(TAG, \"Mutex create failed\");\n        return;\n    }\n\n     q_numbers = xQueueCreate(5, sizeof(struct DataPacket)); // length 5\n    if (q_numbers == NULL) {\n        ESP_LOGE(TAG, \"Queue create failed\");\n        return;\n    }\n\n    q_errors = xQueueCreate(10, sizeof(struct ErrorStatus));\n    if (q_errors == NULL) {\n        ESP_LOGE(TAG, \"Error queue create failed\");\n        return;\n    }\n\n    xTaskCreate(error_task, \"error_task\", 2048, NULL, 0, NULL);\n    xTaskCreate(heartbeat_task, \"heartbeat\", 2048, NULL, 0, NULL);\n    xTaskCreate(bpm_task, \"bpm_task\", 2048, NULL, 1, NULL);\n    xTaskCreate(hearbeatLED_task, \"hearbeatLED_task\", 2048, NULL, 1, NULL);\n    xTaskCreate(producer_task, \"producer_task\", 2048, NULL, 2, NULL);\n    xTaskCreate(consumer_task, \"consumer_task\", 2048, NULL, 2, NULL);\n    xTaskCreate(button_task1, \"button_task1\", 2048, NULL, 3, NULL);\n    xTaskCreate(button_task2, \"button_task2\", 2048, NULL, 3, NULL);\n\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos%20II/tarea3/#task-without-error-logging-system_1","title":"Task without error logging system","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"freertos/FreeRTOS.h\"\n#include \"freertos/task.h\"\n#include \"freertos/semphr.h\"\n#include \"driver/gpio.h\"\n#include \"freertos/queue.h\"\n#include \"esp_log.h\"\n\n\n#define LED_GPIO GPIO_NUM_8   // CHANGE for your board\n#define BUTTON_GPIO GPIO_NUM_10 // CHANGE for your board\n\nstatic const char *TAG = \"HearbeatApp\";\nvolatile bool error[7] = {false, false, false, false, false, false};\n\nstatic QueueHandle_t q_numbers;\nstatic QueueHandle_t q_errors;\nstatic SemaphoreHandle_t shared_counter;\n\nstruct DataPacket {\n    int id;\n    float value;\n};\n\nstruct ErrorStatus {\n    int task_id;\n    bool error_state;\n};\n\nstatic void button_task1(void *pvParameters)\n{\n    gpio_reset_pin(BUTTON_GPIO);\n    gpio_set_direction(BUTTON_GPIO, GPIO_MODE_INPUT);\n    gpio_set_pull_mode(BUTTON_GPIO, GPIO_PULLUP_ONLY);\n    float pressed_time = 0.0f;\n\n    while (1) {\n        bool current_state = !gpio_get_level(BUTTON_GPIO); // Active low\n        if (current_state) {\n            pressed_time += 0.05f; // Simulating time increment\n        } \n        else if (!current_state &amp;&amp; pressed_time &gt; 0.0f) {\n            ESP_LOGI(TAG, \"Button 1 pressed for %f seconds\", pressed_time);\n\n            struct ErrorStatus status = {5, false};\n            xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n\n            pressed_time = 0.0f;\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(50)); // Polling delay\n    }\n}\n\nstatic void button_task2(void *pvParameters)\n{\n    gpio_reset_pin(BUTTON_GPIO);\n    gpio_set_direction(BUTTON_GPIO, GPIO_MODE_INPUT);\n    gpio_set_pull_mode(BUTTON_GPIO, GPIO_PULLUP_ONLY);\n    float pressed_time = 0.0f;\n\n    while (1) {\n        bool current_state = !gpio_get_level(BUTTON_GPIO); // Active low\n        if (current_state) {\n            pressed_time += 0.05f; // Simulating time increment\n        }\n        else if (!current_state &amp;&amp; pressed_time &gt; 0.0f) {\n            ESP_LOGI(TAG, \"Button 2 pressed for %f seconds\", pressed_time);\n\n            struct ErrorStatus status = {6, false};\n            xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n\n            pressed_time = 0.0f;\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(50)); // Polling delay\n    }\n}\n\nstatic void producer_task(void *pvParameters)\n{\n    struct DataPacket packet;\n    packet.id = 0;\n    packet.value = 0.0f;\n    while (1) {\n       packet.id=rand()%1000;\n       packet.value=(float)(rand()%1000)/10.0f;\n\n        // Send to queue; wait up to 50ms if full\n        if (xQueueSend(q_numbers, &amp;packet, pdMS_TO_TICKS(50)) == pdPASS) {\n            struct ErrorStatus status = {3, false};\n            xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n            ESP_LOGI(TAG, \"Produced %d with value %f\", packet.id, packet.value);\n        } else {\n            struct ErrorStatus status = {3, false};\n            xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n            ESP_LOGW(TAG, \"Queue full, dropped %d with value %f\", packet.id, packet.value);\n        }\n\n        vTaskDelay(pdMS_TO_TICKS(200));\n    }\n}\n\nstatic void consumer_task(void *pvParameters)\n{\n     struct DataPacket packet_recv;\n\n    while (1) {\n        // Wait up to 1000ms for data\n        if (xQueueReceive(q_numbers, &amp;packet_recv, pdMS_TO_TICKS(1500)) == pdPASS) {\n            struct ErrorStatus status = {4, false};\n            xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n            ESP_LOGI(TAG, \"Consumed %d with value %f\", packet_recv.id, packet_recv.value);\n        } else {\n            struct ErrorStatus status = {4, false};\n            xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n            ESP_LOGW(TAG, \"No data in 1s\");\n        }\n    }\n}\n\nstatic void heartbeat_task(void *pvParameters)\n{\n    while (1) {\n        struct ErrorStatus status = {0, false};\n        xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n        ESP_LOGI(TAG, \"alive\");\n        vTaskDelay(pdMS_TO_TICKS(2000));\n    }\n}\n\nstatic void hearbeatLED_task(void *pvParameters)\n{\n    gpio_reset_pin(LED_GPIO);\n    gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);\n\n    while (1) {\n        struct ErrorStatus status = {2, false};\n        xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n        gpio_set_level(LED_GPIO, 1);\n        vTaskDelay(pdMS_TO_TICKS(300));\n        gpio_set_level(LED_GPIO, 0);\n        vTaskDelay(pdMS_TO_TICKS(300));\n    }\n}\n\nstatic void bpm_task(void *pvParameters){\n    while (1) {\n        struct ErrorStatus status = {1, false};\n        xQueueSend(q_errors, &amp;status, pdMS_TO_TICKS(10));\n        printf(\"BPM: %d\\n\", rand()%40 + 60);\n        vTaskDelay(pdMS_TO_TICKS(500));\n    }\n}\n\nstatic void error_task(void *pvParameters)\n{\n    struct ErrorStatus status;\n    while (1) {\n        if (xQueueReceive(q_errors, &amp;status, pdMS_TO_TICKS(100)) == pdPASS) {\n            if (xSemaphoreTake(shared_counter, pdMS_TO_TICKS(10)) == pdTRUE) {\n                error[status.task_id] = status.error_state;\n                xSemaphoreGive(shared_counter);\n            }\n        }\n    }\n}\n\nvoid app_main(void)\n{\n    // Create mutex for shared resources\n    shared_counter = xSemaphoreCreateMutex();\n    if (shared_counter == NULL) {\n        ESP_LOGE(TAG, \"Mutex create failed\");\n        return;\n    }\n\n     q_numbers = xQueueCreate(5, sizeof(struct DataPacket)); // length 5\n    if (q_numbers == NULL) {\n        ESP_LOGE(TAG, \"Queue create failed\");\n        return;\n    }\n\n    q_errors = xQueueCreate(10, sizeof(struct ErrorStatus));\n    if (q_errors == NULL) {\n        ESP_LOGE(TAG, \"Error queue create failed\");\n        return;\n    }\n\n    xTaskCreate(error_task, \"error_task\", 2048, NULL, 0, NULL);\n    xTaskCreate(heartbeat_task, \"heartbeat\", 2048, NULL, 0, NULL);\n    xTaskCreate(bpm_task, \"bpm_task\", 2048, NULL, 1, NULL);\n    xTaskCreate(hearbeatLED_task, \"hearbeatLED_task\", 2048, NULL, 1, NULL);\n    xTaskCreate(producer_task, \"producer_task\", 2048, NULL, 2, NULL);\n    xTaskCreate(consumer_task, \"consumer_task\", 2048, NULL, 2, NULL);\n    xTaskCreate(button_task1, \"button_task1\", 2048, NULL, 3, NULL);\n    xTaskCreate(button_task2, \"button_task2\", 2048, NULL, 3, NULL);\n\n}\n</code></pre>"},{"location":"Sistemas%20Embebidos%20II/tarea3/#6-files-media","title":"6) Files &amp; Media","text":"<ul> <li>Firmware file: Descargar main.c</li> <li>Videos: <ol> <li>Task without error logging system</li> <li>Task with error logging system</li> </ol> </li> </ul>"},{"location":"Tareas/","title":"\ud83d\uddc2\ufe0f Sistemas embebidos I \u2014 Portada","text":"<p>Bienvenido a la secci\u00f3n de Sistemas embebidos I del portafolio. Aqu\u00ed recopilo pr\u00e1cticas con Raspberry Pi Pico 2.</p>"},{"location":"Tareas/#indice","title":"\u00cdndice","text":"<ul> <li> <p>Tarea 1 \u2014 Comparaci\u00f3n y ranking de microcontroladores </p> </li> <li> <p>Tarea 2 \u2014 Outputs b\u00e1sicos con l\u00f3gica y m\u00e1scaras </p> </li> <li> <p>Tarea 3 \u2014 Inputs con l\u00f3gica y m\u00e1scaras </p> </li> <li> <p>Tarea 4 \u2014 Mini-Pong con ISR (5 LEDs) </p> </li> <li> <p>Tarea 5 \u2014 Ejercicios de medicion  </p> </li> <li> <p>Tarea 6 \u2014 Ejercicios de Programaci\u00f3n </p> </li> <li> <p>Tarea 7 \u2014 PWM </p> </li> <li> <p>Tarea 8 \u2014 UART </p> </li> <li> <p>Examen \u2014 Sim\u00f3n Dice (4 colores) </p> </li> </ul>"},{"location":"Tareas/Examen/","title":"\ud83d\udcd8 Examen \u2014 Sim\u00f3n Dice (4 colores) \u00b7 Raspberry Pi Pico 2","text":"<p>Juego de memoria con 4 LEDs y 4 botones en Raspberry Pi Pico 2 (RP2350), con secuencia aleatoria que crece por ronda, tiempo l\u00edmite por entrada y fallos por bot\u00f3n incorrecto, por dos pulsaciones simult\u00e1neas o por timeout.  </p>"},{"location":"Tareas/Examen/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Sim\u00f3n Dice (4 colores) \u2013 Pico 2  </li> <li>Autor: Carlos Ernesto Camacho Gonz\u00e1lez  </li> <li>Curso / Asignatura: Sistemas Embebidos  </li> <li>Fecha: 22/09/2025  </li> <li>Descripci\u00f3n breve: Implementaci\u00f3n de un juego \u201cSim\u00f3n Dice\u201d con reproducci\u00f3n de secuencia, entrada del jugador con TL = 5 s + longitud de la ronda, y antirrebote por flanco. Se usa el timer de sistema con ALARM0/ALARM1 para marcar la reproducci\u00f3n y el timeout de entrada, y GPIO IRQ para leer botones sin polling.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n la l\u00f3gica sin bucles de polling: usa interrupciones del timer y de GPIO para conseguir respuesta inmediata y timing preciso.</p>"},{"location":"Tareas/Examen/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Desarrollar un juego completo con interrupciones (timer + GPIO), antirrebote por flancos y manejo de estados.</li> <li>Espec\u00edficos:</li> <li>Reproducir la secuencia actual LED por LED con temporizaci\u00f3n fija.</li> <li>Aceptar la entrada del jugador bajo un tiempo l\u00edmite dependiente de la ronda.</li> <li>Detectar fallos por bot\u00f3n equivocado, doble pulsaci\u00f3n simult\u00e1nea o exceso de tiempo.</li> <li>Asegurar aleatoriedad de la secuencia en cada ejecuci\u00f3n.</li> </ul>"},{"location":"Tareas/Examen/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: </li> <li>GPIO como salidas (LED0..LED3) y entradas con pull-up (BTN0..BTN3).  </li> <li>Timer HW en modo \u00b5s con ALARM0 (reproducci\u00f3n) y ALARM1 (timeout).  </li> <li>IRQ de GPIO con antirrebote por flanco (30 ms).  </li> <li>Detecci\u00f3n de pulsaci\u00f3n m\u00faltiple (&gt;1 bot\u00f3n) como fallo.</li> <li>No incluye: </li> <li>Display de 7 segmentos (omitido).  </li> <li>Almacenamiento de puntaje en memoria o audio.</li> </ul>"},{"location":"Tareas/Examen/#4-requisitos","title":"4) Requisitos","text":"<p>Hardware - Raspberry Pi Pico 2 (RP2350). - 4 LEDs con resistencias de 220\u2013330 \u03a9 conectados a GPIO 0..3. - 4 botones tipo push conectados a GPIO 4..7 con pull-up interno (a GND al presionar). - Protoboard y cables.</p> <p>Software - Pico SDK configurado (RP2350). - CMake + Ninja o tu entorno preferido.</p> <p>Conocimientos previos - Interrupciones (timer y GPIO). - Manejo de m\u00e1scaras y GPIO. - Conceptos de debounce y deadline.</p>"},{"location":"Tareas/Examen/#5-reglas-del-juego-aplicadas","title":"5) Reglas del juego (aplicadas)","text":"<ul> <li>Inicio/Reset: al energizar, LEDs apagados; cualquier bot\u00f3n inicia la Ronda 1.  </li> <li>Reproducci\u00f3n: se muestra la secuencia actual (LED por LED) a 0.5 s por paso.  </li> <li>Entrada: el jugador repite la secuencia completa dentro de TL = 5 s + ronda.  </li> <li>Fallo (Game Over): </li> <li>Bot\u00f3n incorrecto en cualquier paso.  </li> <li>Dos o m\u00e1s botones presionados a la vez durante la fase de entrada.  </li> <li>Exceder TL (timeout).  </li> <li>Progresi\u00f3n: si acierta, ronda++, se a\u00f1ade 1 color aleatorio y se repite.  </li> <li>Fin: al fallar o al completar NMAX_RONDAS (configurada en el c\u00f3digo como 8).</li> </ul>"},{"location":"Tareas/Examen/#6-mapa-de-pines-y-conexion","title":"6) Mapa de pines y conexi\u00f3n","text":"Se\u00f1al GPIO Tipo Conexi\u00f3n recomendada LED0 0 OUT LED\u2192R(220\u2013330 \u03a9)\u2192GPIO 0; c\u00e1todo a GND LED1 1 OUT LED\u2192R\u2192GPIO 1; c\u00e1todo a GND LED2 2 OUT LED\u2192R\u2192GPIO 2; c\u00e1todo a GND LED3 3 OUT LED\u2192R\u2192GPIO 3; c\u00e1todo a GND BTN0 4 IN Bot\u00f3n a GND; habilita pull-up interno BTN1 5 IN Bot\u00f3n a GND; habilita pull-up interno BTN2 6 IN Bot\u00f3n a GND; habilita pull-up interno BTN3 7 IN Bot\u00f3n a GND; habilita pull-up interno <p>Con esta topolog\u00eda, el nivel activo es bajo (0) al presionar.</p>"},{"location":"Tareas/Examen/#7-conceptos-clave-rapido","title":"7) Conceptos clave (r\u00e1pido)","text":"<ul> <li>Debounce (antirrebote): Filtrado temporal (p. ej., 30 ms) para ignorar rebotes al cambiar de estado el bot\u00f3n. Aqu\u00ed se hace por flanco, validando solo transiciones 1\u21920 estables.  </li> <li>Deadline / Timeout (TL): L\u00edmite de tiempo para completar la entrada. Se programa con una alarma del timer: si llega y la tarea no se complet\u00f3, falla.  </li> <li>Edge IRQ: Interrupci\u00f3n por flanco (subida/bajada); evita polling y mejora la latencia.  </li> <li>Secuencia aleatoria: <code>rand()%4</code> con semilla desde <code>time_us_32()</code> desfasada.</li> </ul>"},{"location":"Tareas/Examen/#8-codigo-completo-c-pico-sdk","title":"8) C\u00f3digo completo (C \u00b7 Pico SDK)","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include \"pico/stdlib.h\"\n#include \"pico/time.h\"\n#include \"hardware/gpio.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n// LEDs y botones\n#define LED0 0\n#define LED1 1\n#define LED2 2\n#define LED3 3\n#define BTN0 4\n#define BTN1 5\n#define BTN2 6\n#define BTN3 7\n\n#define NMAX_RONDAS 8\n\n// Estados del juego\nvolatile bool START = false;\nvolatile bool START_SECUENCIA = false;\nvolatile bool START_ESPERA = false;\n\nstatic volatile uint8_t SECUENCIA[NMAX_RONDAS];\nstatic volatile uint8_t RONDA = 0;\nstatic volatile uint8_t RONDA_ACTUAL = 0;\nstatic volatile uint8_t CONTADOR = 0;\n\n// Alarmas\n#define ALARMA_SECUENCIA 0\n#define ALARMA_ESPERA    1\n#define ALARMA_SECUENCIA_IRQ timer_hardware_alarm_get_irq_num(timer_hw, ALARMA_SECUENCIA)\n#define ALARMA_ESPERA_IRQ    timer_hardware_alarm_get_irq_num(timer_hw, ALARMA_ESPERA)\n\nstatic volatile uint32_t NEXT_AS_US, NEXT_AE_US;\nstatic const uint32_t INTERVALO_AS_US = 500000u;  // 0.5 s (ritmo de reproducci\u00f3n)\nstatic const uint32_t BASE_AE_US      = 5000000u; // 5 s base del TL\n\n// Antirrebote por flanco\nstatic const uint32_t DEBOUNCE_US = 30000u; // 30 ms\nstatic volatile uint32_t LAST_EDGE_US[4] = {0,0,0,0};\nstatic volatile uint8_t  LAST_STATE[4]   = {1,1,1,1}; // 1 = suelto (pull-up), 0 = presionado\n\n// Prototipos\nstatic void GENERAR_ELEMENTO(void);\nstatic void BLINK_SECUENCIA(void);\nstatic void SISTEMA_DE_ESPERA(void);\nstatic void START_AS(void);\nstatic void STOP_AS(void);\nstatic void START_AE(void);\nstatic void STOP_AE(void);\nstatic void BTN_ISR(uint gpio, uint32_t events); // ISR de botones\nstatic inline uint8_t BOTONES_PRESIONADOS(void);\nstatic inline void GAME_OVER(void);\n\nint main(void) {\n    stdio_init_all();\n\n    // LEDs\n    for (uint8_t i = LED0; i &lt;= LED3; i++) {\n        gpio_init(i);\n        gpio_set_dir(i, GPIO_OUT);\n        gpio_put(i, 0);\n    }\n    // Botones (pull-up interno)\n    for (uint8_t i = BTN0; i &lt;= BTN3; i++) {\n        gpio_init(i);\n        gpio_set_dir(i, GPIO_IN);\n        gpio_pull_up(i);\n    }\n\n    // Semilla random\n    srand((time_us_32() * 7) ^ (time_us_32() &gt;&gt; 3));\n\n    // Timer HW\n    timer_hw-&gt;source = 0u;\n    hw_clear_bits(&amp;timer_hw-&gt;intr, (1u &lt;&lt; ALARMA_SECUENCIA) | (1u &lt;&lt; ALARMA_ESPERA));\n    irq_set_exclusive_handler(ALARMA_SECUENCIA_IRQ, BLINK_SECUENCIA);\n    irq_set_exclusive_handler(ALARMA_ESPERA_IRQ,    SISTEMA_DE_ESPERA);\n\n    // IRQ de botones: flancos de subida y bajada\n    gpio_set_irq_enabled_with_callback(BTN0, GPIO_IRQ_EDGE_FALL | GPIO_IRQ_EDGE_RISE, true, &amp;BTN_ISR);\n    gpio_set_irq_enabled(BTN1, GPIO_IRQ_EDGE_FALL | GPIO_IRQ_EDGE_RISE, true);\n    gpio_set_irq_enabled(BTN2, GPIO_IRQ_EDGE_FALL | GPIO_IRQ_EDGE_RISE, true);\n    gpio_set_irq_enabled(BTN3, GPIO_IRQ_EDGE_FALL | GPIO_IRQ_EDGE_RISE, true);\n\n    // Bucle ocioso (sin polling)\n    while (true) {\n        tight_loop_contents(); // o __wfi()\n    }\n}\n\n/*** Helpers ***/\nstatic void GENERAR_ELEMENTO(void){\n    if (RONDA &lt;= NMAX_RONDAS) SECUENCIA[RONDA - 1] = rand() % 4;\n}\n\nstatic inline void GAME_OVER(void){\n    for (uint8_t j = 0; j &lt; 4; j++) gpio_put(j, 0);\n    STOP_AE(); STOP_AS();\n    START = false;\n    START_ESPERA = false;\n    START_SECUENCIA = false;\n}\n\nstatic inline uint8_t BOTONES_PRESIONADOS(void){\n    // Cuenta cu\u00e1ntos est\u00e1n a nivel bajo (activo) en este instante\n    uint8_t c = 0;\n    c += (gpio_get(BTN0) == 0);\n    c += (gpio_get(BTN1) == 0);\n    c += (gpio_get(BTN2) == 0);\n    c += (gpio_get(BTN3) == 0);\n    return c;\n}\n\n/*** ISR secuencia (reproducci\u00f3n) ***/\nstatic void BLINK_SECUENCIA(void){\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARMA_SECUENCIA);\n    if (!START_SECUENCIA) { STOP_AS(); return; }\n\n    static bool ENCENDIDO = false;\n    if (RONDA == 0) { STOP_AS(); return; }\n\n    uint8_t led = SECUENCIA[CONTADOR];\n    if (!ENCENDIDO) {\n        gpio_put(led, 1);\n        ENCENDIDO = true;\n    } else {\n        gpio_put(led, 0);\n        ENCENDIDO = false;\n        CONTADOR++;\n    }\n\n    NEXT_AS_US += INTERVALO_AS_US;\n    timer_hw-&gt;alarm[ALARMA_SECUENCIA] = NEXT_AS_US;\n\n    if (CONTADOR &gt;= RONDA &amp;&amp; !ENCENDIDO) {\n        CONTADOR = 0;\n        START_SECUENCIA = false;\n        START_ESPERA = true;\n        STOP_AS();\n        START_AE(); // TL = 5 s + RONDA (segundos)\n    }\n}\n\n/*** ISR espera l\u00edmite (timeout de entrada) ***/\nstatic void SISTEMA_DE_ESPERA(void){\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARMA_ESPERA);\n    if (START_ESPERA) {\n        // Tiempo agotado =&gt; fallo\n        GAME_OVER();\n    }\n}\n\n/*** Alarmas ***/\nstatic void START_AS(void){\n    uint32_t now = timer_hw-&gt;timerawl;\n    NEXT_AS_US = now + INTERVALO_AS_US;\n    timer_hw-&gt;alarm[ALARMA_SECUENCIA] = NEXT_AS_US;\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARMA_SECUENCIA);\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARMA_SECUENCIA);\n    irq_set_enabled(ALARMA_SECUENCIA_IRQ, true);\n}\nstatic void STOP_AS(void){\n    hw_clear_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARMA_SECUENCIA);\n    irq_set_enabled(ALARMA_SECUENCIA_IRQ, false);\n}\nstatic void START_AE(void){\n    uint32_t now = timer_hw-&gt;timerawl;\n    NEXT_AE_US = now + BASE_AE_US + ((uint32_t)RONDA) * 1000000u; // TL = 5s + RONDA\n    timer_hw-&gt;alarm[ALARMA_ESPERA] = NEXT_AE_US;\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARMA_ESPERA);\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARMA_ESPERA);\n    irq_set_enabled(ALARMA_ESPERA_IRQ, true);\n}\nstatic void STOP_AE(void){\n    hw_clear_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARMA_ESPERA);\n    irq_set_enabled(ALARMA_ESPERA_IRQ, false);\n}\n\n/*** ISR de BOTONES (GPIO) con antirrebote por flanco\n     + detecci\u00f3n de pulsaci\u00f3n m\u00faltiple (fail) ***/\nstatic void BTN_ISR(uint gpio, uint32_t events) {\n    uint32_t now = time_us_32();\n    int i = (int)gpio - BTN0; // BTN0..BTN3 =&gt; 0..3\n    if (i &lt; 0 || i &gt; 3) return;\n\n    // Nivel actual (pull-up =&gt; 1 = suelto, 0 = presionado)\n    int level = gpio_get(gpio) ? 1 : 0;\n\n    // Flanco de subida: solo cierra ciclo (no hay l\u00f3gica de juego)\n    if (events &amp; GPIO_IRQ_EDGE_RISE) {\n        if ((now - LAST_EDGE_US[i]) &gt;= DEBOUNCE_US) {\n            LAST_STATE[i]   = 1;   // estable en alto (suelto)\n            LAST_EDGE_US[i] = now;\n        }\n        return;\n    }\n\n    // Flanco de bajada: validar debounce + transici\u00f3n 1-&gt;0 real\n    if (events &amp; GPIO_IRQ_EDGE_FALL) {\n        if ((now - LAST_EDGE_US[i]) &lt; DEBOUNCE_US) return;      // rebote temporal\n        if (!(LAST_STATE[i] == 1 &amp;&amp; level == 0)) return;        // no es 1-&gt;0 estable\n        LAST_STATE[i]   = 0;\n        LAST_EDGE_US[i] = now;\n\n        // --- REGLA NUEVA: si en fase de entrada hay &gt;1 bot\u00f3n presionado =&gt; fallo ---\n        if (START_ESPERA) {\n            if (BOTONES_PRESIONADOS() &gt; 1) {\n                GAME_OVER();\n                return;\n            }\n        }\n\n        // --- L\u00d3GICA DE JUEGO (id\u00e9ntica al dise\u00f1o original) ---\n        if (!START) {\n            // iniciar juego\n            START = true;\n            RONDA = 1;\n            RONDA_ACTUAL = 0;\n            CONTADOR = 0;\n            GENERAR_ELEMENTO();\n            START_SECUENCIA = true;\n            START_AS();\n        } else if (START_ESPERA) {\n            if ((uint8_t)i == SECUENCIA[RONDA_ACTUAL]) {\n                RONDA_ACTUAL++;\n                if (RONDA_ACTUAL &gt;= RONDA) {\n                    if (RONDA &gt;= NMAX_RONDAS) {\n                        // Gan\u00f3\n                        for (uint8_t j = 0; j &lt; 4; j++) gpio_put(j, 1);\n                        START = false;\n                        START_ESPERA = false;\n                        START_SECUENCIA = false;\n                        STOP_AS();\n                        STOP_AE();\n                    } else {\n                        // siguiente ronda\n                        RONDA_ACTUAL = 0;\n                        RONDA++;\n                        GENERAR_ELEMENTO();\n                        START_SECUENCIA = true;\n                        START_ESPERA = false;\n                        CONTADOR = 0;\n                        STOP_AE();\n                        START_AS();\n                    }\n                }\n            } else {\n                // error (bot\u00f3n incorrecto)\n                GAME_OVER();\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"Tareas/ProyectoFinal/","title":"\ud83d\udc2d Proyecto \u2014 Micromouse (Apstone)","text":"<p>Robot m\u00f3vil aut\u00f3nomo que explora un laberinto, construye un mapa y ejecuta una fast run \u00f3ptima hacia el centro.</p>"},{"location":"Tareas/ProyectoFinal/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Micromouse  </li> <li>Autor(es): [Equipo Micromouse] </li> <li>Curso / Asignatura: Apstone / Proyecto de Ingenier\u00eda  </li> <li>Modo de operaci\u00f3n: <code>MODO_ARENA</code> (binario final para competencia)  </li> <li>Descripci\u00f3n breve:   Desarrollo de un robot aut\u00f3nomo capaz de explorar un laberinto 16\u00d716, construir su mapa, encontrar una ruta \u00f3ptima y ejecutar una carrera r\u00e1pida minimizando el tiempo total.</li> </ul> <p>Idea clave</p> <p>El objetivo no es solo que el robot llegue a la meta, sino que lo haga r\u00e1pido, robusto y de forma repetible, con buena ingenier\u00eda detr\u00e1s.</p>"},{"location":"Tareas/ProyectoFinal/#2-alcance-y-entregables-obligatorios","title":"2) Alcance y entregables obligatorios","text":""},{"location":"Tareas/ProyectoFinal/#21-alcance","title":"2.1 Alcance","text":"<p>El proyecto incluye:</p> <ul> <li>Dise\u00f1o mec\u00e1nico, electr\u00f3nico y de control del Micromouse.  </li> <li>Algoritmos de:</li> <li>Exploraci\u00f3n del laberinto.</li> <li>Construcci\u00f3n de mapa (memoria / estructuras de datos).</li> <li>B\u00fasqueda de ruta y fast run.</li> <li>Implementaci\u00f3n de:</li> <li><code>MODO_ARENA</code> para competencia.</li> <li>Mecanismos de seguridad (kill switch, bater\u00eda protegida, etc.).</li> </ul> <p>No incluye (opcional / extra):</p> <ul> <li>Comunicaci\u00f3n inal\u00e1mbrica durante la carrera.  </li> <li>Interfaces gr\u00e1ficas avanzadas.  </li> <li>Telemetr\u00eda compleja en tiempo real durante el evento (solo setup).</li> </ul>"},{"location":"Tareas/ProyectoFinal/#22-entregables-obligatorios","title":"2.2 Entregables obligatorios","text":"<ul> <li>\u2705 Robot funcional con binario <code>MODO_ARENA</code>.  </li> <li>\u2705 Bit\u00e1cora t\u00e9cnica final (1 p\u00e1gina) con:</li> <li>Arquitectura y diagrama (pinout y clocks).  </li> <li>Pruebas clave y resultados.  </li> <li>M\u00e9tricas y decisiones de dise\u00f1o.  </li> <li>Lecciones aprendidas.</li> <li>\u2705 C\u00f3digo fuente:</li> <li>Repositorio con rama estable.  </li> <li>Tag de release del binario usado en la competencia.  </li> <li>Mapa de pines y configuraci\u00f3n de relojes (clocks).</li> <li>\u2705 Acta de resultados del evento firmada por jueces.</li> </ul>"},{"location":"Tareas/ProyectoFinal/#3-especificaciones-del-laberinto","title":"3) Especificaciones del laberinto \ud83e\uddf1","text":"<ul> <li>Tama\u00f1o total: 16\u00d716 celdas.  </li> <li>Zona objetivo: \u00e1rea 2\u00d72 en el centro del laberinto.  </li> <li>Celdas: \u2248 15\u00d715 cm.  </li> <li>Paredes: \u2248 5 cm de alto (puede variar).  </li> <li>Superficie: nivelada, con fricci\u00f3n suficiente para tracci\u00f3n.  </li> <li>Condici\u00f3n de meta:   La meta se considera alcanzada cuando el centro geom\u00e9trico del robot entra en la zona objetivo.</li> </ul> <p>Implicaci\u00f3n de dise\u00f1o</p> <p>Tus algoritmos de posici\u00f3n/odometr\u00eda deben ser lo bastante buenos para saber cu\u00e1ndo el centro del robot est\u00e1 dentro de la celda objetivo, no solo cuando la punta \u201cparece\u201d llegar.</p>"},{"location":"Tareas/ProyectoFinal/#4-reglas-del-robot","title":"4) Reglas del robot \ud83e\udd16","text":"<ul> <li>Autonom\u00eda total:   No se permite ning\u00fan control humano durante el intento.</li> <li>Dimensiones m\u00e1ximas:   \u2264 12\u00d712\u00d712 cm. El peso es libre.</li> <li>Seguridad:</li> <li>Sin elementos punzantes ni cortantes.</li> <li>Sin l\u00edquidos, humo ni materiales inflamables.</li> <li>Sin piezas sueltas.</li> <li>Kill switch:</li> <li>Obligatorio.  </li> <li>Accesible sin levantar el robot.</li> <li>Integridad del hardware:</li> <li>Cableado firme.  </li> <li>Bater\u00eda protegida mec\u00e1nica y el\u00e9ctricamente.</li> </ul> <p>Seguridad primero</p> <p>Un robot que no pasa inspecci\u00f3n de seguridad no participa, aunque funcione perfecto a nivel de control.</p>"},{"location":"Tareas/ProyectoFinal/#5-formato-de-competencia","title":"5) Formato de competencia \ud83c\udfc1","text":"<ul> <li>Cada equipo dispone de hasta 3 intentos cronometrados.  </li> <li>Cada intento incluye dos fases:</li> <li>Exploraci\u00f3n (map building).  </li> <li>Fast run (carrera \u00f3ptima con el mapa ya construido).</li> <li>Acciones inv\u00e1lidas (anulan el intento):</li> <li>Asistencia manual al robot.  </li> <li>Levantar el robot del laberinto.  </li> <li>Salida deliberada de pista.  </li> <li>Da\u00f1o al laberinto o a otros robots.</li> </ul>"},{"location":"Tareas/ProyectoFinal/#6-cronograma-del-evento-min","title":"6) Cronograma del evento (min) \u23f1\ufe0f","text":"Tiempo Actividad 00:00\u201300:10 Registro e inspecci\u00f3n de seguridad 00:10\u201300:15 Briefing (reglas y orden) 00:15\u201301:30 Clasificatorios 01:30\u201301:50 Final 01:50\u201302:00 Premiaci\u00f3n y firma de actas"},{"location":"Tareas/ProyectoFinal/#7-inspeccion-tecnica-checklist","title":"7) Inspecci\u00f3n t\u00e9cnica (checklist) \u2705","text":"<p>Checklist previo a la competencia:</p> <ul> <li>[ ] Dimensiones \u2264 12\u00d712\u00d712 cm.  </li> <li>[ ] Kill switch accesible y probado.  </li> <li>[ ] Bater\u00eda y cableado asegurados; sin bordes peligrosos.  </li> <li>[ ] <code>MODO_ARENA</code> cargado (sin logs verbosos ni debug excesivo).  </li> <li>[ ] CLI / telemetr\u00eda usados solo en setup (no en carrera).  </li> <li>[ ] Sin control remoto durante la carrera.</li> </ul> <p>Buen h\u00e1bito</p> <p>Haz esta checklist antes de ir al evento para evitar sorpresas en la mesa de inspecci\u00f3n.</p>"},{"location":"Tareas/ProyectoFinal/#8-puntuacion-bonos-y-penalizaciones","title":"8) Puntuaci\u00f3n, bonos y penalizaciones \ud83e\uddee","text":"<ul> <li>Tiempo base (Tc):   Mejor fast run del equipo en segundos.</li> </ul>"},{"location":"Tareas/ProyectoFinal/#81-bonos-restan-tiempo","title":"8.1 Bonos (restan tiempo)","text":"<ul> <li>Exploraci\u00f3n \u00fanica (sin reset entre explorar y fast run): \u22125 s.  </li> <li>Cero colisiones (validado por jueces): \u22123 s.</li> </ul>"},{"location":"Tareas/ProyectoFinal/#82-penalizaciones-suman-tiempo","title":"8.2 Penalizaciones (suman tiempo)","text":"<ul> <li>Colisi\u00f3n clara: +2 s por colisi\u00f3n (m\u00e1x. +10 s).  </li> <li>Reinicio manual durante fast run: +5 s.  </li> <li>Levantar el robot / salida de pista: intento inv\u00e1lido.</li> </ul>"},{"location":"Tareas/ProyectoFinal/#83-formula-final","title":"8.3 F\u00f3rmula final","text":"<p>[ P = T_c + \\text{Bonos} - \\text{Penalizaciones} ]</p> <p>Nota: usa signos coherentes (bonos negativos, penalizaciones positivas) al calcular.</p>"},{"location":"Tareas/ProyectoFinal/#9-criterios-de-desempate","title":"9) Criterios de desempate","text":"<ol> <li>Menor fast run (solo Tc, sin bonos/penalizaciones).  </li> <li>Menor tiempo de exploraci\u00f3n.  </li> <li>Si persiste el empate: sorteo supervisado (coin toss).</li> </ol>"},{"location":"Tareas/ProyectoFinal/#10-documentacion-y-entregas-tecnicas","title":"10) Documentaci\u00f3n y entregas t\u00e9cnicas \ud83d\udcc4","text":""},{"location":"Tareas/ProyectoFinal/#bitacora-tecnica-final-1-pagina","title":"Bit\u00e1cora t\u00e9cnica final (1 p\u00e1gina)","text":"<p>Debe incluir:</p> <ul> <li>Arquitectura y diagrama </li> <li>Esquema general del sistema.  </li> <li>Pinout y configuraci\u00f3n de clocks.  </li> <li>Pruebas clave:</li> <li>PIO  </li> <li>DMA  </li> <li>UART  </li> <li>WDT (watchdog)  </li> <li>Energ\u00eda (reguladores, bater\u00eda)  </li> <li>EMC / ruido  </li> <li>Uso multicore (si aplica)</li> <li>M\u00e9tricas:</li> <li>Tiempos de ejecuci\u00f3n por tareas cr\u00edticas.  </li> <li>Jitter de tareas/ISRs.  </li> <li>% de uso de CPU.  </li> <li>P\u00e9rdidas de FIFO/DMA.  </li> <li>Consumo de corriente (exploraci\u00f3n vs fast run).</li> <li>Decisiones de dise\u00f1o y rationale:   Por qu\u00e9 se eligieron ciertos sensores, motores, topolog\u00edas de control, etc.</li> <li>Lecciones aprendidas:   Qu\u00e9 sali\u00f3 bien, qu\u00e9 fall\u00f3, qu\u00e9 se mejorar\u00eda en una siguiente versi\u00f3n.</li> <li>Dise\u00f1o de PCB:   Imagen del layout, capas, consideraciones de ruteo.  </li> <li>C\u00f3digo y binarios:   Referencia clara a repositorio, tag y binario final.</li> </ul>"},{"location":"Tareas/ProyectoFinal/#11-calificacion","title":"11) Calificaci\u00f3n \ud83c\udf93","text":"<ul> <li>Desempe\u00f1o en competencia (ranking, P) \u2014 40%</li> <li>1\u00ba \u2014 40%  </li> <li>2\u00ba \u2014 36%  </li> <li>3\u00ba \u2014 32%  </li> <li>4\u00ba \u2014 28%  </li> <li>5\u00ba \u2014 24%  </li> <li>6\u00ba \u2014 20%  </li> <li>7\u00ba \u2014 16%  </li> <li> <p>8\u00ba \u2014 12%</p> </li> <li> <p>Ingenier\u00eda y robustez del mouse \u2014 30%   PCB, programaci\u00f3n, pruebas y calidad de integraci\u00f3n.</p> </li> <li> <p>Requisitos t\u00e9cnicos \u2014 20%   Cumplimiento de especificaciones del proyecto y del laberinto.</p> </li> <li> <p>Bit\u00e1cora t\u00e9cnica \u2014 10%   Claridad, s\u00edntesis, m\u00e9trica y calidad de la documentaci\u00f3n.</p> </li> </ul>"},{"location":"Tareas/ProyectoFinal/#12-materiales-y-componentes","title":"12) Materiales y componentes \ud83d\udd27","text":"<p>Lista inicial (completar en la bit\u00e1cora con modelos exactos):</p> <ul> <li>Tracci\u00f3n</li> <li>2 \u00d7 Micro motorreductor con encoder (6 V DC, compatibles con RPM/torque requeridos).</li> <li>Sensores</li> <li>3 \u00d7 Sensores de muro / distancia  <ul> <li>(ej. Sharp IR / TOF / reflectivos \u2014 especificar modelo exacto).  </li> </ul> </li> <li>Control</li> <li>2 \u00d7 Raspberry Pi Pico 2 (RP2040).  </li> <li>Potencia</li> <li>1 \u00d7 Puente H (driver de motor, modelo a especificar).  </li> <li>1 \u00d7 Regulador 9 V \u2192 5 V.  </li> <li>1 \u00d7 Regulador 5 V \u2192 3.3 V.  </li> <li>1 \u00d7 Bater\u00eda (especificar tecnolog\u00eda y capacidad).</li> <li>Mec\u00e1nica y ensamble</li> <li>1 \u00d7 PCB propia (mouse).  </li> <li>Chasis impreso en 3D.  </li> <li>Conectores, torniller\u00eda, cables.  </li> <li>Kill switch.</li> </ul> <p>Nota: en la bit\u00e1cora final agrega marca, modelo, cantidades y hojas de datos relevantes.</p>"},{"location":"Tareas/ProyectoFinal/#13-imagenes-disenos","title":"13) Im\u00e1genes / dise\u00f1os \ud83d\uddbc\ufe0f","text":""},{"location":"Tareas/ProyectoFinal/#131-esquematico-en-altium","title":"13.1 Esquem\u00e1tico en Altium","text":"<p>Esquem\u00e1tico del sistema: RP2350 / Pico, driver HW-166, reguladores 9V\u21925V y 5V\u21923.3V, conectores de sensores, motores, bater\u00eda y switch.</p>"},{"location":"Tareas/ProyectoFinal/#132-pcb-del-micromouse","title":"13.2 PCB del Micromouse","text":"<p>Dise\u00f1o de PCB de una sola cara para el Micromouse, optimizado al contorno del chasis con conectores laterales para motores y sensores.</p>"},{"location":"Tareas/ProyectoFinal/#133-impresion-3d-del-chasis","title":"13.3 Impresi\u00f3n 3D del chasis","text":"<p>Impresi\u00f3n de las piezas del chasis en impresoras 3D (Ender y Prusa MK4S), usando PLA, con varias pruebas de ajuste.</p> <p></p> <p>Detalle de la impresi\u00f3n del chasis principal en la Prusa MK4S durante el 88% del trabajo.</p>"},{"location":"Tareas/ProyectoFinal/#134-ensamble-electronico-y-mecanico","title":"13.4 Ensamble electr\u00f3nico y mec\u00e1nico","text":"<p>PCB ya fresada y soldada, montada sobre el chasis 3D, con cableado hacia el driver de motores y la bater\u00eda.</p> <p></p> <p>Vista lateral del robot con ruedas, interruptor lateral y distribuci\u00f3n interna de cables.</p>"},{"location":"Tareas/ProyectoFinal/#135-pruebas-en-el-laberinto","title":"13.5 Pruebas en el laberinto","text":"<p>Micromouse realizando pruebas iniciales dentro del laberinto f\u00edsico, validando locomoci\u00f3n, espacio disponible y detecci\u00f3n de paredes.</p>"},{"location":"Tareas/ProyectoFinal/#136-video-de-pruebas-en-el-laberinto","title":"13.6 Video de pruebas en el laberinto","text":"<p>Video de pruebas del Micromouse en el laberinto f\u00edsico. El robot ya logra moverse y reaccionar a las paredes, aunque a\u00fan no es la versi\u00f3n final ni la m\u00e1s estable \ud83d\ude05.</p>"},{"location":"Tareas/ProyectoFinal/#14-pruebas-recomendadas","title":"14) Pruebas recomendadas \ud83d\udd0d","text":"<ul> <li>Odometr\u00eda y filtro de pose:</li> <li>Validaci\u00f3n del error de posici\u00f3n por celda.  </li> <li>Sensores:</li> <li>Latencia de lectura.  </li> <li>Jitter de muestreo (con o sin DMA).  </li> <li>Control de motores:</li> <li>Respuesta a escal\u00f3n de PWM.  </li> <li>Overshoot, tiempo de establecimiento, velocidad m\u00e1xima estable.</li> <li>Gesti\u00f3n energ\u00e9tica:</li> <li>Consumo en exploraci\u00f3n vs fast run.  </li> <li>Autonom\u00eda esperada por carga de bater\u00eda.</li> <li>Robustez:</li> <li>Pruebas con peque\u00f1as colisiones.  </li> <li>Pruebas de ca\u00edda controlada desde poca altura (si aplica).</li> </ul> <p>Made with Material for MkDocs \ud83e\udde9</p>"},{"location":"Tareas/tarea1/","title":"\ud83d\udcd8 Tarea 1 \u2014 Comparaci\u00f3n y ranking de microcontroladores","text":"<p>Documento de comparaci\u00f3n y ranking de 4 MCUs.</p>"},{"location":"Tareas/tarea1/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Comparaci\u00f3n y ranking de microcontroladores  </li> <li>Autor: Carlos Ernesto Camacho Gonz\u00e1lez</li> <li>Curso / Asignatura: Sistemas Embebidos  </li> <li>Fecha: 27/08/2025  </li> <li>Descripci\u00f3n breve: Se comparan ESP32, STM32F103C8T6, RP2040 y ATmega328P en perif\u00e9ricos, memoria, ecosistema, costo y rendimiento para proponer un ranking de uso recomendado.</li> </ul> <p>Consejo</p> <p>Elige el MCU seg\u00fan el contexto: conectividad IoT, facilidad para aprender, costo o escalabilidad industrial.</p>"},{"location":"Tareas/tarea1/#2-objetivos","title":"2) Objetivos","text":"<ul> <li> <p>General: Identificar el microcontrolador m\u00e1s conveniente seg\u00fan requisitos t\u00edpicos de proyectos de mecatr\u00f3nica.</p> </li> <li> <p>Espec\u00edficos:</p> </li> <li>Comparar perif\u00e9ricos y conectividad integrada.</li> <li>Contrastar memoria, arquitectura y frecuencia de trabajo.</li> <li>Valorar el ecosistema (IDE/SDK, documentaci\u00f3n y comunidad).</li> <li>Considerar costo aproximado en MXN y facilidad de uso.</li> <li>Proponer un ranking justificado y casos de uso sugeridos.</li> </ul>"},{"location":"Tareas/tarea1/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: 4 MCUs representativos (ESP32, STM32F103C8T6, RP2040, ATmega328P) y su comparaci\u00f3n a nivel hoja de datos/experiencia general.  </li> <li>No incluye: Benchmarks el\u00e9ctricos finos (sleep, ruido anal\u00f3gico), pruebas RF, certificaciones ni costos de producci\u00f3n en volumen.</li> </ul>"},{"location":"Tareas/tarea1/#4-requisitos","title":"4) Requisitos","text":"<p>Software - Editor (VS Code) y navegador. - (Opcional) MkDocs + Material para publicar.</p> <p>Hardware (si se desea experimentar) - ESP32-DevKit, Blue Pill (STM32F103C8T6), Raspberry Pi Pico (RP2040), Arduino UNO (ATmega328P).</p> <p>Conocimientos previos - Lectura b\u00e1sica de datasheets y pinouts. - Perif\u00e9ricos: ADC, UART, SPI, I\u00b2C, PWM. - Flujo con IDE/SDK (Arduino IDE, ESP-IDF, Pico SDK, STM32CubeIDE).</p>"},{"location":"Tareas/tarea1/#5-microcontroladores-elegidos","title":"5) Microcontroladores elegidos","text":"<ul> <li>ESP32 (Espressif)  </li> <li>STM32F103C8T6 (STMicroelectronics)  </li> <li>RP2040 (Raspberry Pi Pico)  </li> <li>ATmega328P (Arduino UNO, Microchip)  </li> </ul>"},{"location":"Tareas/tarea1/#6-tabla-comparativa","title":"6) Tabla comparativa","text":"MCU + Marca Perif\u00e9ricos Memoria (Flash / RAM) Ecosistema Costo aprox. (MXN) Arquitectura Velocidad de trabajo ESP32 (Espressif) Wi-Fi, Bluetooth, ADC 12b, 2\u00d7DAC, UART, SPI, I\u00b2C, PWM, touch ~4 MB Flash (m\u00f3dulo), ~520 KB SRAM Arduino IDE o ESP-IDF, comunidad IoT 120\u2013250 Xtensa LX6 dual-core 32 bits 240 MHz STM32F103C8T6 (ST) ADC 12b, UART, CAN, I\u00b2C, SPI, timers 64 KB Flash, 20 KB SRAM STM32CubeIDE/HAL, uso industrial 100\u2013250 ARM Cortex-M3 32 bits 72 MHz RP2040 (Raspberry Pi) 2\u00d7ADC, UART, SPI, I\u00b2C, PWM, PIO programable 2 MB Flash, 264 KB SRAM SDK C/C++ y MicroPython, comunidad amplia 150\u2013200 ARM Cortex-M0+ dual-core 32 bits 133 MHz ATmega328P (Microchip) ADC 10b, UART, SPI, I\u00b2C, timers 32 KB Flash, 2 KB SRAM Arduino IDE, comunidad educativa enorme 200\u2013300 (Arduino UNO) AVR 8 bits 16 MHz <pre><code>note \"Precios\"\nCostos referenciales en MXN; var\u00edan por marca/placa, memoria y disponibilidad.\n</code></pre>"},{"location":"Tareas/tarea1/#7-criterios-usados-para-el-ranking","title":"7) Criterios usados para el ranking","text":"<ul> <li>Conectividad integrada (Wi-Fi/BLE) para IoT.  </li> <li>Ecosistema/soporte (IDE oficiales, SDKs, documentaci\u00f3n, comunidad).  </li> <li>Rendimiento (arquitectura, n\u00facleos y frecuencia).  </li> <li>Memoria disponible (Flash/RAM \u00fatiles).  </li> <li>Costo y facilidad de aprendizaje/puesta en marcha.</li> </ul>"},{"location":"Tareas/tarea1/#8-ranking-de-microcontroladores-con-justificacion","title":"8) Ranking de microcontroladores (con justificaci\u00f3n)","text":"<ol> <li> <p>ESP32    Mayor cantidad de perif\u00e9ricos y conectividad Wi-Fi/Bluetooth integrada, buen rendimiento y bajo costo. Ideal para IoT, prototipado r\u00e1pido y proyectos de mecatr\u00f3nica actuales.</p> </li> <li> <p>RP2040 (Raspberry Pi Pico)    Doble n\u00facleo, PIO muy flexible y comunidad enorme. No trae radio integrada, pero es vers\u00e1til y econ\u00f3mico para control, procesamiento ligero y aprendizaje.</p> </li> <li> <p>STM32F103C8T6 (Blue Pill)    Arquitectura ARM Cortex-M3 y presencia en industria. Excelente para aprender HAL/STM32CubeIDE. Curva de aprendizaje m\u00e1s alta que ESP32/Pico.</p> </li> <li> <p>ATmega328P (Arduino UNO)    Limitado en memoria/velocidad, pero con la comunidad educativa m\u00e1s grande y facil\u00edsimo para empezar. \u00datil en pr\u00e1cticas introductorias y proyectos simples.</p> </li> </ol>"},{"location":"Tareas/tarea1/#9-conclusiones-y-recomendaciones","title":"9) Conclusiones y recomendaciones","text":"<ul> <li>Si necesitas IoT con bajo costo y rapidez \u2192 ESP32.  </li> <li>Si quieres control flexible y aprender concurrente/PIO \u2192 RP2040.  </li> <li>Si el enfoque es industrial/ARM y HAL \u2192 STM32F103C8T6.  </li> <li>Para educaci\u00f3n b\u00e1sica y prototipos simples \u2192 ATmega328P.</li> </ul>"},{"location":"Tareas/tarea2/","title":"\ud83d\udcd8 Tarea 2 \u2014 Outputs b\u00e1sicos con l\u00f3gica y m\u00e1scaras","text":"<p>Tres pr\u00e1cticas con GPIO en Raspberry Pi Pico: contador binario, barrido de LEDs y secuencia en c\u00f3digo Gray.</p>"},{"location":"Tareas/tarea2/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Outputs b\u00e1sicos con l\u00f3gica y m\u00e1scaras  </li> <li>Autor: Carlos Ernesto Camacho Gonz\u00e1lez </li> <li>Curso / Asignatura: Sistemas Embebidos  </li> <li>Fecha: 27/08/2025  </li> <li>Descripci\u00f3n breve: Implementaci\u00f3n de patrones de salida con GPIO usando m\u00e1scaras: contador de 4 bits, barrido tipo \u201cping-pong\u201d y generaci\u00f3n de c\u00f3digo Gray.</li> </ul> <p>Consejo</p> <p>Usa m\u00e1scaras (<code>MASK</code>) para configurar y escribir varios pines a la vez: el c\u00f3digo queda m\u00e1s corto y r\u00e1pido.</p>"},{"location":"Tareas/tarea2/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Practicar el uso de m\u00e1scaras de bits para controlar m\u00faltiples GPIO y consolidar patrones de salida.</li> <li>Espec\u00edficos:</li> <li>Generar un contador binario de 4 bits.</li> <li>Implementar un barrido asc/desc de LEDs.</li> <li>Producir una secuencia Gray de 3 bits usando operaciones a nivel bit.</li> </ul>"},{"location":"Tareas/tarea2/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Configuraci\u00f3n de GPIO como salida, escritura en paralelo con <code>gpio_put_masked</code> / <code>gpio_set_mask</code> / <code>gpio_clr_mask</code>, y temporizaci\u00f3n con <code>sleep_ms</code>.</li> <li>No incluye: Interrupciones.</li> </ul>"},{"location":"Tareas/tarea2/#4-requisitos","title":"4) Requisitos","text":"<p>Hardware - Raspberry Pi Pico / Pico 2. - 3\u20135 LEDs con resistencias (220\u2013330 \u03a9) y cableado a los GPIO indicados.</p> <p>Conocimientos previos - M\u00e1scaras de bits, operaciones l\u00f3gicos.</p>"},{"location":"Tareas/tarea2/#contador-binario-de-4-bits","title":"Contador binario de 4 bits","text":""},{"location":"Tareas/tarea2/#nombre-del-codigo","title":"Nombre del c\u00f3digo","text":"<p>Contador binario (4 bits)</p>"},{"location":"Tareas/tarea2/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<p>Genera un contador binario ascendente de 4 bits. Los LEDs muestran los valores de 0 a 15, actualizando cada 500 ms.</p>"},{"location":"Tareas/tarea2/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define A 0\n#define B 1\n#define C 2\n#define D 3\n\nint main() {\n    const uint32_t MASK = (1u&lt;&lt;A) | (1u&lt;&lt;B) | (1u&lt;&lt;C) | (1u&lt;&lt;D);\n\n    gpio_init_mask(MASK);\n    gpio_set_dir_masked(MASK, MASK);\n\n    while (true) {\n        for (uint8_t i = 0; i &lt; 16; i++) {\n            // Escribe i en los pines A..D\n            gpio_put_masked(MASK, (uint32_t)i &lt;&lt; A);\n            sleep_ms(500);\n        }\n    }\n}\n</code></pre>"},{"location":"Tareas/tarea2/#esquematico-de-conexion","title":"Esquem\u00e1tico de conexi\u00f3n","text":""},{"location":"Tareas/tarea2/#video","title":"Video","text":""},{"location":"Tareas/tarea2/#barrido-de-leds","title":"Barrido de LEDs","text":""},{"location":"Tareas/tarea2/#nombre-del-codigo_1","title":"Nombre del c\u00f3digo","text":"<p>Barrido de LEDs (\u201cping-pong\u201d)</p>"},{"location":"Tareas/tarea2/#que-debe-hacer_1","title":"Qu\u00e9 debe hacer","text":"<p>Enciende un LED a la vez en orden ascendente (0\u21921\u21922\u21923\u21924) y luego descendente (4\u21923\u21922\u21921), repitiendo la secuencia.</p>"},{"location":"Tareas/tarea2/#codigo_1","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define A 0   \n#define B 1   \n#define C 2   \n#define D 3 \n#define E 4  \n\nint main() {\n    const uint32_t MASK = (1u&lt;&lt;A) | (1u&lt;&lt;B) | (1u&lt;&lt;C) | (1u&lt;&lt;D) | (1u&lt;&lt;E);\n\n    gpio_init_mask(MASK);\n    gpio_set_dir_out_masked(MASK);\n    gpio_clr_mask(MASK);\n\n    while (true) {\n        // Subida: 0..4\n        for (int i = 0; i &lt; 5; ++i) {\n            gpio_clr_mask(MASK);\n            gpio_set_mask(1u &lt;&lt; i);\n            sleep_ms(300);\n        }\n        // Bajada: 3..1 (evita repetir extremos 4 y 0)\n        for (int i = 3; i &gt; 0; --i) {\n            gpio_clr_mask(MASK);\n            gpio_set_mask(1u &lt;&lt; i);\n            sleep_ms(300);\n        }\n    }\n}\n</code></pre>"},{"location":"Tareas/tarea2/#esquematico-de-conexion_1","title":"Esquem\u00e1tico de conexi\u00f3n","text":""},{"location":"Tareas/tarea2/#video_1","title":"Video","text":""},{"location":"Tareas/tarea2/#secuencia-en-codigo-gray","title":"Secuencia en c\u00f3digo Gray","text":""},{"location":"Tareas/tarea2/#nombre-del-codigo_2","title":"Nombre del c\u00f3digo","text":"<p>Secuencia en c\u00f3digo Gray (3 bits)</p>"},{"location":"Tareas/tarea2/#que-debe-hacer_2","title":"Qu\u00e9 debe hacer","text":"<p>Muestra la secuencia Gray de 3 bits: en cada transici\u00f3n solo cambia 1 bit. Se usa la f\u00f3rmula <code>gray = n ^ (n &gt;&gt; 1)</code>.</p>"},{"location":"Tareas/tarea2/#codigo_2","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n#define A 0\n#define B 1\n#define C 2\n\nstatic inline uint8_t bin_to_gray(uint8_t n) {\n    return (uint8_t)(n ^ (n &gt;&gt; 1));\n}\n\nint main() {\n    const uint32_t MASK = (1u&lt;&lt;A) | (1u&lt;&lt;B) | (1u&lt;&lt;C);\n\n    gpio_init_mask(MASK);\n    gpio_set_dir_masked(MASK, MASK);\n\n    while (true) {\n        for (uint8_t i = 0; i &lt; 8; i++) {\n            uint8_t gray = bin_to_gray(i);\n            // Escribe gray en pines A..C\n            gpio_put_masked(MASK, (uint32_t)gray &lt;&lt; A);\n            sleep_ms(500);\n        }\n    }\n}\n</code></pre>"},{"location":"Tareas/tarea2/#esquematico-de-conexion_2","title":"Esquem\u00e1tico de conexi\u00f3n","text":""},{"location":"Tareas/tarea2/#video_2","title":"Video","text":""},{"location":"Tareas/tarea2/#6-resultados-y-conclusiones","title":"6) Resultados y conclusiones","text":"<ul> <li>Las m\u00e1scaras simplifican la configuraci\u00f3n y escritura simult\u00e1nea de varios GPIO.  </li> <li>El barrido demuestra control individual y temporizaci\u00f3n consistente.  </li> <li>La secuencia Gray valida operaciones bit a bit (<code>^</code>, <code>&gt;&gt;</code>) y su aplicaci\u00f3n pr\u00e1ctica en minimizar cambios simult\u00e1neos.</li> </ul> <p>Pr\u00f3ximos pasos: portar a interrupciones/PIO</p>"},{"location":"Tareas/tarea3/","title":"\ud83d\udcd8 Tarea 3 \u2014 Inputs con l\u00f3gica y m\u00e1scaras","text":"<p>Dos pr\u00e1cticas con botones y LEDs en Raspberry Pi Pico: compuertas l\u00f3gicas AND/OR/XOR y selector c\u00edclico con avance/retroceso.</p>"},{"location":"Tareas/tarea3/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Inputs con l\u00f3gica y m\u00e1scaras  </li> <li>Autor: Carlos Ernesto Camacho Gonz\u00e1lez </li> <li>Curso / Asignatura: Sistemas Embebidos  </li> <li>Fecha: 01/09/2025  </li> <li>Descripci\u00f3n breve: Se leen botones pull-up (presionado=0) para generar salidas en LEDs usando operadores l\u00f3gicos y m\u00e1scaras. Se implementa antirrebote por detecci\u00f3n de flanco.</li> </ul> <p>Consejo</p> <p>Con pull-up, el bot\u00f3n presionado lee <code>0</code>. Invierte con <code>!gpio_get(pin)</code> para tratar \u201cpresionado = 1\u201d.</p>"},{"location":"Tareas/tarea3/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Practicar lectura de entradas digitales y generaci\u00f3n de salidas usando operadores l\u00f3gicos y m\u00e1scaras.</li> <li>Espec\u00edficos:</li> <li>Implementar AND/OR/XOR en hardware con botones y LEDs.</li> <li>Dise\u00f1ar un selector c\u00edclico con avance y retroceso sin repetici\u00f3n mientras se mantiene presionado.</li> <li>Aplicar antirrebote por flanco con variables de estado previo.</li> </ul>"},{"location":"Tareas/tarea3/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Lectura de GPIO, pull-ups internos, escritura en GPIO, m\u00e1scaras y detecci\u00f3n por flanco.  </li> <li>No incluye: interrupciones.</li> </ul>"},{"location":"Tareas/tarea3/#4-requisitos","title":"4) Requisitos","text":"<p>Hardware - Raspberry Pi Pico / Pico 2. - 6 botones (pull-up) y 7\u20138 LEDs con resistencias.</p> <p>Conocimientos previos - Operadores l\u00f3gicos y operaciones de bits. - Pull-up/pull-down y l\u00f3gica activa-baja.</p>"},{"location":"Tareas/tarea3/#compuertas-basicas-and-or-xor-con-2-botones-por-puerta","title":"Compuertas b\u00e1sicas AND / OR / XOR con 2 botones por puerta","text":""},{"location":"Tareas/tarea3/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<p>Con botones pull-up (presionado=0) se encienden tres LEDs que muestran el resultado de AND, OR y XOR. En los videos se ejemplifican las combinaciones.</p>"},{"location":"Tareas/tarea3/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n\n// Pines AND\n#define BTN_A 0      \n#define BTN_B 1    \n#define LED0  6\n// Pines OR\n#define BTN_C 2     \n#define BTN_D 3    \n#define LED1  7\n// Pines XOR\n#define BTN_E 4      \n#define BTN_F 5    \n#define LED2  8\n\nstatic inline bool ANDf(void) {\n    bool A_PRESS = !gpio_get(BTN_A);\n    bool B_PRESS = !gpio_get(BTN_B);\n    return (A_PRESS &amp;&amp; B_PRESS);\n}\n\nstatic inline bool ORf(void) {\n    bool C_PRESS = !gpio_get(BTN_C);\n    bool D_PRESS = !gpio_get(BTN_D);\n    return (C_PRESS || D_PRESS);\n}\n\nstatic inline bool XORf(void) {\n    bool E_PRESS = !gpio_get(BTN_E);\n    bool F_PRESS = !gpio_get(BTN_F);\n    return (E_PRESS ^ F_PRESS);\n}\n\nint main(void) {\n    // LEDs salida\n    gpio_init(LED0); gpio_set_dir(LED0, GPIO_OUT);\n    gpio_init(LED1); gpio_set_dir(LED1, GPIO_OUT);\n    gpio_init(LED2); gpio_set_dir(LED2, GPIO_OUT);\n\n    // Botones con pull-up\n    gpio_init(BTN_A); gpio_set_dir(BTN_A, GPIO_IN); gpio_pull_up(BTN_A);\n    gpio_init(BTN_B); gpio_set_dir(BTN_B, GPIO_IN); gpio_pull_up(BTN_B);\n\n    gpio_init(BTN_C); gpio_set_dir(BTN_C, GPIO_IN); gpio_pull_up(BTN_C);\n    gpio_init(BTN_D); gpio_set_dir(BTN_D, GPIO_IN); gpio_pull_up(BTN_D);\n\n    gpio_init(BTN_E); gpio_set_dir(BTN_E, GPIO_IN); gpio_pull_up(BTN_E);\n    gpio_init(BTN_F); gpio_set_dir(BTN_F, GPIO_IN); gpio_pull_up(BTN_F);\n\n    while (true) {\n        gpio_put(LED0, ANDf());\n        gpio_put(LED1, ORf());\n        gpio_put(LED2, XORf());\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"Tareas/tarea3/#esquematico-de-conexion-and","title":"Esquem\u00e1tico de conexi\u00f3n AND","text":""},{"location":"Tareas/tarea3/#compuerta-and","title":"Compuerta AND","text":""},{"location":"Tareas/tarea3/#esquematico-de-conexion-or","title":"Esquem\u00e1tico de conexi\u00f3n OR","text":""},{"location":"Tareas/tarea3/#compuerta-or","title":"Compuerta OR","text":""},{"location":"Tareas/tarea3/#esquematico-de-conexion-xor","title":"Esquem\u00e1tico de conexi\u00f3n XOR","text":""},{"location":"Tareas/tarea3/#compuerta-xor","title":"Compuerta XOR","text":""},{"location":"Tareas/tarea3/#selector-ciclico-de-4-leds-con-avanceretroceso-antirrebote-por-flanco","title":"Selector c\u00edclico de 4 LEDs con avance/retroceso (antirrebote por flanco)","text":""},{"location":"Tareas/tarea3/#que-debe-hacer_1","title":"Qu\u00e9 debe hacer","text":"<p>Se mantiene un solo LED encendido entre LED0..LED3. Un bot\u00f3n AVANZA (0\u21921\u21922\u21923\u21920) y otro RETROCEDE (0\u21923\u21922\u21921\u21920). Un push = un paso (si se deja presionado no repite gracias a la detecci\u00f3n de flanco).</p>"},{"location":"Tareas/tarea3/#codigo_1","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n\n#define BTN_PREV 0      \n#define BTN_NEXT 1    \n#define LED0   2\n#define LED1   3\n#define LED2   4\n#define LED3   5\n\nuint8_t STATE = LED0 - 1;\n\nint main(void) {\n    const uint8_t LEDs_M = (1u &lt;&lt; LED0 | 1u &lt;&lt; LED1 | 1u &lt;&lt; LED2 | 1u &lt;&lt; LED3);\n\n    gpio_init_mask(LEDs_M);\n    gpio_set_dir_out_masked(LEDs_M);\n    gpio_set_mask(LEDs_M);   \n    gpio_clr_mask(LEDs_M);\n\n    gpio_init(BTN_PREV);\n    gpio_set_dir(BTN_PREV, GPIO_IN);\n    gpio_pull_up(BTN_PREV);\n\n    gpio_init(BTN_NEXT);\n    gpio_set_dir(BTN_NEXT, GPIO_IN);\n    gpio_pull_up(BTN_NEXT);\n\n    bool NEXT_PREVSTATE = 1;\n    bool PREV_PREVSTATE = 1;\n\n    while (true) {\n        bool NEXT_STATE = !gpio_get(BTN_NEXT);\n        bool PREV_STATE = !gpio_get(BTN_PREV);\n\n        // Siguiente LED\n        if (NEXT_STATE &amp;&amp; !NEXT_PREVSTATE) {\n            if (STATE == LED3) {\n                STATE = LED0;\n            } else {\n                STATE ++;\n            }\n            gpio_clr_mask(LEDs_M);                \n            gpio_set_mask(1 &lt;&lt; STATE);              \n        }\n\n        // Anterior LED\n        if (PREV_STATE &amp;&amp; !PREV_PREVSTATE) {\n            if (STATE == LED0) {\n                STATE = LED3;\n            } else {\n                STATE --;\n            }\n            gpio_clr_mask(LEDs_M);                \n            gpio_set_mask(1 &lt;&lt; STATE);              \n        }\n\n        NEXT_PREVSTATE = NEXT_STATE;\n        PREV_PREVSTATE = PREV_STATE;\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"Tareas/tarea3/#demostracion","title":"Demostraci\u00f3n","text":""},{"location":"Tareas/tarea3/#5-resultados-y-conclusiones","title":"5) Resultados y conclusiones","text":"<ul> <li> <p>Las compuertas AND/OR/XOR se implementan directamente con operadores l\u00f3gicos, cumpliendo \u201csin enumerar combinaciones\u201d.</p> </li> <li> <p>El selector c\u00edclico usa m\u00e1scaras para encender exactamente un LED.</p> </li> </ul>"},{"location":"Tareas/tarea4/","title":"\ud83d\udcd8 Tarea 4 \u2014 Mini-Pong con ISR (5 LEDs)","text":""},{"location":"Tareas/tarea4/#nombre-del-codigo","title":"Nombre del c\u00f3digo","text":"<p>Mini-Pong ISR (5 LEDs, 2 botones, RP2040)</p>"},{"location":"Tareas/tarea4/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<p>La \u201cpelota\u201d es un LED que recorre 5 LEDs en l\u00ednea (L1\u2192L5\u2192L1\u2026) a un ritmo fijo. Cada bot\u00f3n genera una interrupci\u00f3n (ISR) y solo cuenta si se presiona exactamente cuando la pelota est\u00e1 en el extremo de ese lado: BTN_L solo en L1, BTN_R solo en L5. Si coincide, rebota (invierte direcci\u00f3n). Si no, anota el rival: parpadea 3 veces su LED de punto, se reinicia en L3 y sale hacia quien anot\u00f3. Al encender, la pelota inicia en L3 y no se mueve hasta presionar un bot\u00f3n; arrancar\u00e1 en la direcci\u00f3n opuesta al bot\u00f3n presionado.</p>"},{"location":"Tareas/tarea4/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n// ---------- Pines ----------\n#define BTN_L  0   // Bot\u00f3n jugador IZQUIERDA\n#define BTN_R  1   // Bot\u00f3n jugador DERECHA\n#define PT_L   2   // LED punto IZQUIERDA\n#define PT_R   3   // LED punto DERECHA\n\n// L\u00ednea de 5 LEDs (L1..L5)\n#define L1 4       // extremo izquierdo\n#define L2 5\n#define L3 6       // centro\n#define L4 7\n#define L5 8       // extremo derecho\n\n// ---------- Par\u00e1metros ----------\nstatic const uint32_t STEP_MS  = 120; // ritmo de la pelota\nstatic const uint32_t BLINK_MS = 150; // parpadeo de punto (x3)\n\n// ---------- Estado ----------\nstatic const uint8_t LINE[5] = { L1, L2, L3, L4, L5 };\nstatic volatile bool START = false;     // detenido en L3 hasta primer toque\nstatic volatile int8_t dir = 0;         // -1 izq., +1 der.\nstatic volatile uint8_t idx = 2;        // 0..4 (L3=2)\nstatic volatile uint8_t cur_pin = L3;   // GPIO encendido actual\nstatic volatile bool HIT_L = false;     // golpe v\u00e1lido justo en L1\nstatic volatile bool HIT_R = false;     // golpe v\u00e1lido justo en L5\n\nstatic inline void show_ball(uint8_t new_idx){\n    idx = new_idx;\n    cur_pin = LINE[idx];\n    uint32_t mask_line = (1u&lt;&lt;L1)|(1u&lt;&lt;L2)|(1u&lt;&lt;L3)|(1u&lt;&lt;L4)|(1u&lt;&lt;L5);\n    gpio_clr_mask(mask_line);\n    gpio_set_mask(1u &lt;&lt; cur_pin);\n}\n\nstatic void blink_point(uint pin){\n    for(int i=0;i&lt;3;++i){ gpio_put(pin,1); sleep_ms(BLINK_MS); gpio_put(pin,0); sleep_ms(BLINK_MS); }\n}\n\nstatic void reset_center_and_go(bool to_right){\n    show_ball(2);         // L3\n    START = true;\n    dir = to_right ? +1 : -1;\n}\n\n// ISR: arranque y golpes exactos en extremos\nstatic void isr_buttons(uint gpio, uint32_t events){\n    if(!(events &amp; GPIO_IRQ_EDGE_FALL)) return; // flanco de bajada (pull-up)\n    if(!START){\n        if(gpio==BTN_L){ START=true; dir=+1; } // opuesta al bot\u00f3n\n        else if(gpio==BTN_R){ START=true; dir=-1; }\n        return;\n    }\n    if(gpio==BTN_L &amp;&amp; cur_pin==L1) HIT_L = true;\n    if(gpio==BTN_R &amp;&amp; cur_pin==L5) HIT_R = true;\n}\n\nint main(){\n    stdio_init_all();\n    // LEDs l\u00ednea\n    for(int i=0;i&lt;5;++i){ gpio_init(LINE[i]); gpio_set_dir(LINE[i],GPIO_OUT); gpio_put(LINE[i],0); }\n    // LEDs punto\n    gpio_init(PT_L); gpio_set_dir(PT_L,GPIO_OUT); gpio_put(PT_L,0);\n    gpio_init(PT_R); gpio_set_dir(PT_R,GPIO_OUT); gpio_put(PT_R,0);\n    // Botones (pull-up)\n    gpio_init(BTN_L); gpio_set_dir(BTN_L,GPIO_IN); gpio_pull_up(BTN_L);\n    gpio_init(BTN_R); gpio_set_dir(BTN_R,GPIO_IN); gpio_pull_up(BTN_R);\n    // ISR\n    gpio_set_irq_enabled_with_callback(BTN_L, GPIO_IRQ_EDGE_FALL, true, &amp;isr_buttons);\n    gpio_set_irq_enabled(BTN_R, GPIO_IRQ_EDGE_FALL, true);\n\n    show_ball(2); // L3\n    START=false;\n\n    absolute_time_t last = get_absolute_time();\n    while(true){\n        if(to_ms_since_boot(get_absolute_time()) - to_ms_since_boot(last) &lt; STEP_MS){\n            tight_loop_contents(); continue;\n        }\n        last = get_absolute_time();\n\n        if(!START){ show_ball(2); continue; }\n\n        int8_t next = idx + dir;\n        if(next&lt;0) next=0; if(next&gt;4) next=4;\n        show_ball(next);\n\n        if(idx==0){ // L1\n            if(HIT_L){ dir=+1; }                 // rebote\n            else{ blink_point(PT_R); reset_center_and_go(true); } // punto derecha\n            HIT_L=false;\n        }\n        if(idx==4){ // L5\n            if(HIT_R){ dir=-1; }                 // rebote\n            else{ blink_point(PT_L); reset_center_and_go(false);} // punto izquierda\n            HIT_R=false;\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"Tareas/tarea4/#esquematico-de-conexion-xor","title":"Esquem\u00e1tico de conexi\u00f3n XOR","text":""},{"location":"Tareas/tarea4/#video","title":"video","text":""},{"location":"Tareas/tarea5/","title":"\ud83d\udcd8 Tarea 5 \u2014 Ejercicios de medicion","text":"<p>Genera una onda cuadrada con ALARM0 en interrupci\u00f3n (ISR), con rearme acumulativo y periodo nominal definido. Luego compara modo \u00b5s vs modo ciclos (clk_sys) en el RP2350 (Pico 2).</p>"},{"location":"Tareas/tarea5/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Temporizador de sistema \u2014 ALARM0 y medici\u00f3n de jitter  </li> <li>Autor: Carlos Ernesto Camacho Gonz\u00e1lez </li> <li>Curso / Asignatura: Sistemas Embebidos  </li> <li>Fecha: 15/09/2025  </li> <li>Descripci\u00f3n breve: Se usa el timer del sistema para alternar (toggle) un GPIO desde la ISR de ALARM0.</li> </ul> <p>Consejo</p>"},{"location":"Tareas/tarea5/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Generar una onda cuadrada estable con ALARM0 y caracterizar su jitter.</li> <li>Espec\u00edficos:</li> <li>Implementar ISR de ALARM0 con rearme acumulativo.</li> <li>Medir periodo, jitter p-p y RMS con osciloscopio.</li> <li>Comparar precisi\u00f3n entre modo \u00b5s y modo ciclos (clk_sys).</li> </ul>"},{"location":"Tareas/tarea5/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: GPIO, IRQ, system timer ALARM0, medici\u00f3n con osciloscopio.</li> <li>No incluye: PIO/PWM/DMA.</li> </ul>"},{"location":"Tareas/tarea5/#4-requisitos","title":"4) Requisitos","text":"<p>Hardware - Raspberry Pi Pico 2 (RP2350). - 1 LED + resistencia (o s\u00f3lo el GPIO medido con sonda).</p> <p>Conocimientos previos - Interrupciones, GPIO, y conceptos de jitter/RMS.</p>"},{"location":"Tareas/tarea5/#6-codigo-1","title":"6) C\u00f3digo 1","text":"<pre><code>// Blink con timer (SDK alto nivel): cambia BLINK_MS para ajustar\n#include \"pico/stdlib.h\"\n#include \"pico/time.h\"\n\n#define LED_PIN 0                      // &lt;-- LED externo en GP0\nstatic const int BLINK_MS = 500;       // \"toggle\" cada 500 ms (periodo completo ~1 s)\n\nbool blink_cb(repeating_timer_t *t) {\n    static bool on = false;\n    gpio_put(LED_PIN, on = !on);   // toggle\n    return true;                   // seguir repitiendo\n}\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n\n    repeating_timer_t timer;\n    add_repeating_timer_ms(BLINK_MS, blink_cb, NULL, &amp;timer);\n\n    while (true) {\n        tight_loop_contents();     // trabajo pesado va aqu\u00ed, no en la ISR\n    }\n}\n</code></pre>"},{"location":"Tareas/tarea5/#7-codigo-2","title":"7) C\u00f3digo 2","text":"<pre><code>// Blink con timer de sistema (bajo nivel): ALARM0 + IRQ con rearme acumulativo\n#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n#include \"hardware/structs/sio.h\"\n\n#define LED_PIN    0                    // &lt;-- LED externo en GP0\n#define ALARM_NUM  0                    // usaremos ALARM0\n\n// N\u00famero de IRQ asociado a ALARM0\n#define ALARM_IRQ  timer_hardware_alarm_get_irq_num(timer_hw, ALARM_NUM)\n\n// pr\u00f3ximo instante (en \u00b5s) en los 32 bits bajos del contador\nstatic volatile uint32_t next_deadline;\n// por defecto el timer cuenta en \u00b5s\nstatic volatile uint32_t intervalo_us = 500000u; // &lt;-- \"toggle\" cada 500 ms (periodo completo ~1 s)\n\nvoid on_alarm_irq(void) {\n    // Limpia la IRQ de ALARM0 (write-1-to-clear)\n    hw_set_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM);\n\n    // Toggle del LED\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN;\n\n    // Rearme ACUMULATIVO (evita deriva si la ISR se retrasa)\n    next_deadline += intervalo_us;\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n}\n\nint main() {\n    stdio_init_all();\n\n    // LED de salida\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n    gpio_put(LED_PIN, 0);\n\n    // Primer deadline\n    uint32_t now_us = timer_hw-&gt;timerawl;     // 32 bits bajos (\u00b5s)\n    next_deadline = now_us + intervalo_us;\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n\n    // Enlaza e inicia IRQ\n    irq_set_exclusive_handler(ALARM_IRQ, on_alarm_irq);\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM);\n    irq_set_enabled(ALARM_IRQ, true);\n\n    while (true) {\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"Tareas/tarea5/#7-esquematico-raspberry-pi-pico-2-led-en-gp1","title":"7) Esquematico - Raspberry Pi Pico 2 (LED en GP1)","text":"<p> Figura 1.</p>"},{"location":"Tareas/tarea5/#8-resultados","title":"8) Resultados","text":"<p>Programa 1</p> <ul> <li> <p>Par\u00e1metro del timer: 1.000 s</p> </li> <li> <p>Medici\u00f3n con cursores: \u0394t \u2248 1.001 s </p> </li> <li> <p>Periodo completo de la onda: \u2248 2.002 s</p> </li> </ul> <p> Figura 2. Medici\u00f3n con SDK alto nivel.</p> <p>Programa 2</p> <ul> <li> <p>Par\u00e1metro del timer: 1.000 s</p> </li> <li> <p>Medici\u00f3n con cursores: \u0394t \u2248 1.000\u20131.001 s</p> </li> <li> <p>Periodo completo de la onda: \u2248 2.000\u20132.002 s</p> </li> </ul> <p> Figura 3. Medici\u00f3n con ALARM0 + ISR.</p>"},{"location":"Tareas/tarea5/#9-conclusiones-rapidas","title":"9) Conclusiones r\u00e1pidas","text":"<ul> <li>Ambos m\u00e9todos cumplen el periodo esperado; el desv\u00edo de ~+1 ms (~0.1%) est\u00e1 dentro del l\u00edmite de medici\u00f3n de esa configuraci\u00f3n.</li> </ul>"},{"location":"Tareas/tarea6/","title":"\ud83d\udcd8 Tarea 6 \u2014 Ejercicios de Programaci\u00f3n","text":""},{"location":"Tareas/tarea6/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Multialarmas / Control de velocidad en Pong  </li> <li>Autor: Carlos Ernesto Camacho Gonz\u00e1lez  </li> <li>Curso / Asignatura: Sistemas Embebidos  </li> <li>Fecha: 16/09/2025  </li> <li>Descripci\u00f3n breve: </li> <li>Ejercicio 1: Cuatro LEDs a distintas frecuencias con temporizador de software (sin interrupciones).  </li> <li>Ejercicio 2: Pong con dos botones para subir/bajar la velocidad sin <code>delay</code> usando ALARM0/1 y rearme acumulativo.</li> </ul>"},{"location":"Tareas/tarea6/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Generar y controlar temporizaciones independientes para m\u00faltiples salidas.  </li> <li>Ajustar la velocidad de un juego sin bloquear el bucle principal.  </li> <li>Usar rearme acumulativo y antirrebote por flanco.</li> </ul>"},{"location":"Tareas/tarea6/#3-ejercicio-1-cuatro-alarmas-cuatro-leds-a-distintas-frecuencias-sin-interrupciones","title":"3) Ejercicio 1 \u2014 Cuatro alarmas / cuatro LEDs a distintas frecuencias (sin interrupciones)","text":""},{"location":"Tareas/tarea6/#que-debe-hacer","title":"Qu\u00e9 debe hacer","text":"<p>Configurar cuatro LEDs en pines distintos. Cada LED alterna (toggle) con su intervalo propio usando un temporizador de software basado en <code>time_us_32()</code> (sin IRQ).</p>"},{"location":"Tareas/tarea6/#codigo","title":"C\u00f3digo","text":"<pre><code>// Cuatro LEDs a distintas frecuencias (RP2350 / Pico 2) SIN interrupciones.\n// LED0=GPIO 1, LED1=GPIO 0, LED2=GPIO 2, LED3=GPIO 3.\n\n#include \"pico/stdlib.h\"\n#include \"pico/time.h\"\n#include \"hardware/gpio.h\"\n\n#define LED0_PIN 1   // antes: PICO_DEFAULT_LED_PIN\n#define LED1_PIN 0\n#define LED2_PIN 2\n#define LED3_PIN 3\n\nstatic const uint8_t PINES[4] = { LED0_PIN, LED1_PIN, LED2_PIN, LED3_PIN };\n\n// Intervalo ENTRE toggles (el per\u00edodo visible ON+OFF es el doble)\nstatic const uint32_t INTERVALO_US[4] = {\n    300000u, // GPIO 1: 300 ms\n    200000u, // GPIO 0: 200 ms\n    120000u, // GPIO 2: 120 ms\n     80000u  // GPIO 3: 80 ms\n};\n\nstatic uint32_t next_us[4];\n\nint main(void) {\n    for (int i = 0; i &lt; 4; ++i) {\n        gpio_init(PINES[i]);\n        gpio_set_dir(PINES[i], GPIO_OUT);\n        gpio_put(PINES[i], 0);\n    }\n\n    uint32_t now = time_us_32();\n    for (int i = 0; i &lt; 4; ++i) next_us[i] = now + INTERVALO_US[i];\n\n    while (true) {\n        now = time_us_32();\n        for (int i = 0; i &lt; 4; ++i) {\n            if ((int32_t)(now - next_us[i]) &gt;= 0) {\n                gpio_xor_mask(1u &lt;&lt; PINES[i]);\n                next_us[i] += INTERVALO_US[i];   // rearme acumulativo\n            }\n        }\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"Tareas/tarea6/#esquematico-de-conexion","title":"Esquematico de conexi\u00f3n","text":"<p> Figura 1.</p>"},{"location":"Tareas/tarea6/#video","title":"video","text":""},{"location":"Tareas/tarea6/#4-ejercicio-2-pong-dos-botones-para-subirbajar-velocidad-sin-delay","title":"4) Ejercicio 2 \u2014 Pong: dos botones para subir/bajar velocidad (sin delay)","text":""},{"location":"Tareas/tarea6/#que-debe-hacer_1","title":"Qu\u00e9 debe hacer","text":"<p>A\u00f1adir BTN_MAS (\u2191 velocidad) y BTN_MENOS (\u2193 velocidad). El tempo del juego se controla con ALARMA_JUEGO (modo \u00b5s), rearme acumulativo y antirrebote. El parpadeo de punto va con ALARMA_PUNTO (no bloqueante).</p>"},{"location":"Tareas/tarea6/#codigo_1","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n#include \"hardware/gpio.h\"\n\n#define BTN_J1 0   // Bot\u00f3n jugador izquierda\n#define BTN_J2 1   // Bot\u00f3n jugador derecha\n#define LED_J1 2   // LED indicador puntos J1\n#define LED_J2 3   // LED indicador puntos J2\n#define LED0 4     // Posici\u00f3n 0 de LED\n#define LED1 5\n#define LED2 6     // Centro de LEDs\n#define LED3 7\n#define LED4 8     // Posici\u00f3n 4 de LED\n#define RESET 9    // Bot\u00f3n de reinicio\n\n// Botones NUEVOS\n#define BTN_MAS   10  // Subir velocidad\n#define BTN_MENOS 11  // Bajar velocidad\n\n// Alarmas del timer\n#define ALARMA_JUEGO_NUM  0  // tick de juego\n#define ALARMA_PUNTO_NUM  1  // parpadeo de punto\n#define IRQ_ALARMA_JUEGO  timer_hardware_alarm_get_irq_num(timer_hw, ALARMA_JUEGO_NUM)\n#define IRQ_ALARMA_PUNTO  timer_hardware_alarm_get_irq_num(timer_hw, ALARMA_PUNTO_NUM)\n\n// Velocidades (ms)\n#define VEL_PELOTA 100\n#define VEL_REBOTE 300\n\n// Rango y paso de velocidad (us)\n#define VEL_MIN_US         40000u\n#define VEL_MAX_US        400000u\n#define VEL_PASO_US        20000u    // salto entre us\n#define ANTIRREBOTE_VEL_US 120000u   // antirrebote para botones de velocidad\n\nuint8_t POS = LED2;     // Pelota arranca en el centro\nbool DIR = 1;           // 1 = derecha, 0 = izquierda\nbool START = false;     // Juego detenido al inicio\n\nvolatile bool GOLPE_J1 = false;\nvolatile bool GOLPE_J2 = false;\nvolatile bool START_J1 = false;\nvolatile bool START_J2 = false;\nvolatile bool RESET_STATE = false;\n\n// M\u00e1scaras\nuint32_t LEDS_MASK;\nstatic uint32_t MASCARA_LEDS_POS;     // solo LEDs de posici\u00f3n, no marca\n\n// Tiempo y tick\nstatic inline uint32_t microsegundos(void){ return timer_hw-&gt;timerawl; }\nstatic volatile uint32_t VEL_PELOTA_US = (uint32_t)VEL_PELOTA * 1000u; // periodo del tick en \u00b5s\nstatic volatile uint32_t PROXIMO_TICK_US = 0;\nstatic volatile uint32_t ULTIMO_CAMBIO_VEL_US = 0; // antirrebote de BTN_MAS/BTN_MENOS\n\n// Ventana de rebote fija en tiempo\n#define REBOTE_US ((uint32_t)VEL_REBOTE * 1000u)\nstatic volatile bool EN_PARED = false;\nstatic volatile uint32_t VENTANA_HASTA_US = 0;\n\n// Parpadeo no bloqueante (ALARMA_PUNTO)\nstatic volatile bool PARPADEO_ACTIVO = false;\nstatic volatile uint8_t  PIN_LED_PARPADEO = 0;\nstatic volatile uint8_t  PARPADEOS_RESTANTES = 0;\nstatic volatile uint32_t PROXIMO_PARPADEO_US = 0;\n#define PARPADEO_MEDIO_US 200000u // 200 ms ON/OFF\n\n// Prototipos requeridos\nstatic void PONG(uint PIN, uint32_t EVENT_MASK);\nvoid BLINK(uint8_t LED);\nvoid REINICIAR();\nvoid MOVER_PELOTA(void);\n\n// ---- ISRs de alarmas\nstatic void irq_alarma_juego(void){\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARMA_JUEGO_NUM);\n    MOVER_PELOTA();\n    PROXIMO_TICK_US += VEL_PELOTA_US;                 // rearme acumulativo\n    timer_hw-&gt;alarm[ALARMA_JUEGO_NUM] = PROXIMO_TICK_US;\n}\n\nstatic void irq_alarma_punto(void){\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARMA_PUNTO_NUM);\n\n    if (!PARPADEO_ACTIVO || PARPADEOS_RESTANTES == 0){\n        gpio_put(PIN_LED_PARPADEO, 0);\n        PARPADEO_ACTIVO = false;\n        return;\n    }\n    sio_hw-&gt;gpio_togl = (1u &lt;&lt; PIN_LED_PARPADEO);\n    PARPADEOS_RESTANTES--;\n    PROXIMO_PARPADEO_US += PARPADEO_MEDIO_US;         // rearme acumulativo\n    timer_hw-&gt;alarm[ALARMA_PUNTO_NUM] = PROXIMO_PARPADEO_US;\n}\n\nint main() {\n    // LEDs\n    LEDS_MASK = (1u &lt;&lt; LED_J1) | (1u &lt;&lt; LED_J2) | (1u &lt;&lt; LED0) | (1u &lt;&lt; LED1) |\n                (1u &lt;&lt; LED2) | (1u &lt;&lt; LED3) | (1u &lt;&lt; LED4);\n    MASCARA_LEDS_POS = (1u &lt;&lt; LED0) | (1u &lt;&lt; LED1) | (1u &lt;&lt; LED2) | (1u &lt;&lt; LED3) | (1u &lt;&lt; LED4);\n\n    gpio_init_mask(LEDS_MASK);\n    gpio_set_dir_masked(LEDS_MASK, LEDS_MASK);\n    gpio_clr_mask(LEDS_MASK);\n\n    // Botones\n    gpio_init(BTN_J1);   gpio_set_dir(BTN_J1, GPIO_IN);   gpio_pull_up(BTN_J1);\n    gpio_init(BTN_J2);   gpio_set_dir(BTN_J2, GPIO_IN);   gpio_pull_up(BTN_J2);\n    gpio_init(RESET);    gpio_set_dir(RESET,  GPIO_IN);   gpio_pull_up(RESET);\n    gpio_init(BTN_MAS);  gpio_set_dir(BTN_MAS, GPIO_IN);  gpio_pull_up(BTN_MAS);\n    gpio_init(BTN_MENOS);gpio_set_dir(BTN_MENOS, GPIO_IN);gpio_pull_up(BTN_MENOS);\n\n    gpio_set_mask(1u &lt;&lt; POS); // LED inicial en centro\n\n    // IRQ GPIO por flanco de bajada\n    gpio_set_irq_enabled_with_callback(BTN_J1, GPIO_IRQ_EDGE_FALL, true, &amp;PONG);\n    gpio_set_irq_enabled(BTN_J2,   GPIO_IRQ_EDGE_FALL, true);\n    gpio_set_irq_enabled(RESET,    GPIO_IRQ_EDGE_FALL, true);\n    gpio_set_irq_enabled(BTN_MAS,  GPIO_IRQ_EDGE_FALL, true);\n    gpio_set_irq_enabled(BTN_MENOS,GPIO_IRQ_EDGE_FALL, true);\n\n    // Timer de sistema en \u00b5s\n    timer_hw-&gt;source = 0u;                         // base de tiempo en \u00b5s (RP2350)\n    uint32_t ahora = microsegundos();\n\n    // Programa ALARMA_JUEGO (primer tick)\n    PROXIMO_TICK_US = ahora + VEL_PELOTA_US;\n    timer_hw-&gt;alarm[ALARMA_JUEGO_NUM] = PROXIMO_TICK_US;\n\n    // Limpia flags, registra handlers y habilita\n    hw_clear_bits(&amp;timer_hw-&gt;intr, (1u &lt;&lt; ALARMA_JUEGO_NUM) | (1u &lt;&lt; ALARMA_PUNTO_NUM));\n    irq_set_exclusive_handler(IRQ_ALARMA_JUEGO,  irq_alarma_juego);\n    irq_set_exclusive_handler(IRQ_ALARMA_PUNTO,  irq_alarma_punto);\n    hw_set_bits(&amp;timer_hw-&gt;inte, (1u &lt;&lt; ALARMA_JUEGO_NUM) | (1u &lt;&lt; ALARMA_PUNTO_NUM));\n    irq_set_enabled(IRQ_ALARMA_JUEGO,  true);\n    irq_set_enabled(IRQ_ALARMA_PUNTO,  true);\n\n    while (true) { tight_loop_contents(); }\n}\n\n// ---- ISR GPIO\nstatic void PONG(uint PIN, uint32_t EVENT_MASK) {\n    if (EVENT_MASK &amp; GPIO_IRQ_EDGE_FALL) {\n        if (PIN == BTN_J1) {\n            if (!START) START_J1 = true;\n            else if (POS == LED0) GOLPE_J1 = true;\n        } else if (PIN == BTN_J2) {\n            if (!START) START_J2 = true;\n            else if (POS == LED4) GOLPE_J2 = true;\n        } else if (PIN == RESET) {\n            RESET_STATE = true;\n        } else if (PIN == BTN_MAS || PIN == BTN_MENOS) {\n            uint32_t t = microsegundos();\n            // antirrebote botones de velocidad\n            if ((int32_t)(t - ULTIMO_CAMBIO_VEL_US) &gt; (int32_t)ANTIRREBOTE_VEL_US) {\n                if (PIN == BTN_MAS) {\n                    // m\u00e1s r\u00e1pido = menor periodo\n                    if (VEL_PELOTA_US &gt; VEL_MIN_US + VEL_PASO_US - 1) VEL_PELOTA_US -= VEL_PASO_US;\n                    else VEL_PELOTA_US = VEL_MIN_US;\n                } else {\n                    // m\u00e1s lento = mayor periodo\n                    if (VEL_PELOTA_US &lt; VEL_MAX_US - VEL_PASO_US + 1) VEL_PELOTA_US += VEL_PASO_US;\n                    else VEL_PELOTA_US = VEL_MAX_US;\n                }\n                // re-alinear pr\u00f3ximo tick para notar el cambio de inmediato\n                PROXIMO_TICK_US = t + VEL_PELOTA_US;\n                timer_hw-&gt;alarm[ALARMA_JUEGO_NUM] = PROXIMO_TICK_US;\n                ULTIMO_CAMBIO_VEL_US = t;\n            }\n        }\n    }\n    gpio_acknowledge_irq(PIN, EVENT_MASK);\n}\n\n// BLINK del original: ahora inicia parpadeo no bloqueante\nvoid BLINK(uint8_t LED) {\n    PIN_LED_PARPADEO = LED;\n    PARPADEOS_RESTANTES = 6; // 3 destellos ON/OFF\n    gpio_put(PIN_LED_PARPADEO, 0);\n    PARPADEO_ACTIVO = true;\n    PROXIMO_PARPADEO_US = microsegundos() + PARPADEO_MEDIO_US;\n    timer_hw-&gt;alarm[ALARMA_PUNTO_NUM] = PROXIMO_PARPADEO_US;\n}\n\nvoid REINICIAR() {\n    POS = LED2;\n    START = false;\n    GOLPE_J1 = false;\n    GOLPE_J2 = false;\n    START_J1 = false;\n    START_J2 = false;\n    EN_PARED = false;\n    PARPADEO_ACTIVO = false;\n    gpio_put(LED_J1, 0);\n    gpio_put(LED_J2, 0);\n    gpio_clr_mask(MASCARA_LEDS_POS);\n    gpio_set_mask(1u &lt;&lt; POS); // LED centro\n}\n\nvoid MOVER_PELOTA() {\n    uint32_t tnow = microsegundos();\n\n    if (RESET_STATE) {\n        REINICIAR();\n        RESET_STATE = false;\n        return;\n    }\n\n    if (!START) {\n        if (START_J1) { DIR = 1; START = true; START_J1 = false; }\n        else if (START_J2) { DIR = 0; START = true; START_J2 = false; }\n        gpio_set_mask(1u &lt;&lt; POS); // LED centro\n        return;\n    }\n\n    // Ventana fija cuando est\u00e1 en pared\n    if (EN_PARED) {\n        if ((int32_t)(tnow - VENTANA_HASTA_US) &gt;= 0) {\n            if (POS == LED0) {\n                if (GOLPE_J1) { DIR = 1; }\n                else { BLINK(LED_J2); POS = LED2; DIR = 1; START = true; }\n                GOLPE_J1 = false;\n            } else if (POS == LED4) {\n                if (GOLPE_J2) { DIR = 0; }\n                else { BLINK(LED_J1); POS = LED2; DIR = 0; START = true; }\n                GOLPE_J2 = false;\n            }\n            EN_PARED = false;\n            gpio_clr_mask(MASCARA_LEDS_POS);\n            gpio_set_mask(1u &lt;&lt; POS);\n        }\n        return; // mientras dura la ventana no se mueve\n    }\n\n    // Mover pelota 1 paso\n    if (DIR &amp;&amp; POS &lt; LED4) POS++;\n    else if (!DIR &amp;&amp; POS &gt; LED0) POS--;\n\n    // Si lleg\u00f3 a pared, abrir ventana\n    if (POS == LED0 || POS == LED4) {\n        EN_PARED = true;\n        VENTANA_HASTA_US = tnow + REBOTE_US;\n    }\n\n    gpio_clr_mask(MASCARA_LEDS_POS);\n    gpio_set_mask(1u &lt;&lt; POS);\n}\n</code></pre>"},{"location":"Tareas/tarea6/#esquematico-de-conexion_1","title":"Esquematico de conexi\u00f3n","text":"<p> Figura 2.</p>"},{"location":"Tareas/tarea6/#video_1","title":"video","text":""},{"location":"Tareas/tarea6/#5-resultados-y-conclusiones","title":"5) Resultados y conclusiones","text":"<ul> <li> <p>Ej. 1: Cada LED parpadea a su frecuencia (intervalo configurado). El rearme acumulativo en software mantiene el ritmo sin sleep_ms().</p> </li> <li> <p>Ej. 2: BTN_MAS/BTN_MENOS cambian la velocidad al vuelo con antirrebote y realineo del pr\u00f3ximo tick.</p> </li> </ul>"},{"location":"Tareas/tarea7/","title":"\ud83d\udcd8 Tarea 7 \u2014 PWM","text":""},{"location":"Tareas/tarea7/#tarea-71-control-de-duty-cycle-motor-dc","title":"\ud83c\udfb5 Tarea 7.1 - Control de Duty Cycle \u2014 Motor DC","text":""},{"location":"Tareas/tarea7/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del subproyecto: Control PWM de motor DC con 3 velocidades  </li> <li>Autor: Carlos Ernesto Camacho Gonz\u00e1lez  </li> <li>Curso / Asignatura: Sistemas Embebidos  </li> <li>Fecha: 16/09/2025  </li> <li>Descripci\u00f3n breve: </li> <li>Controlar un motor DC mediante PWM variando el duty cycle.  </li> <li>Dos botones seleccionan tres velocidades predefinidas: baja, media y alta.  </li> <li>Se documentan valores de duty, circuito y c\u00f3digo.  </li> </ul> <p>Nota de seguridad: El microcontrolador no entrega corriente suficiente para un motor. Debe usarse un driver/puente H (p. ej., DRV8833, TB6612FNG o L298N) con fuente para el motor y GND com\u00fan con el micro.</p>"},{"location":"Tareas/tarea7/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Comprender c\u00f3mo el duty cycle del PWM regula la velocidad del motor DC.  </li> <li>Implementar una interfaz simple con dos botones para seleccionar tres velocidades.  </li> <li>Configurar correctamente el hardware PWM en RP2350/Pico 2 (frecuencia, <code>wrap</code>, <code>clkdiv</code>).  </li> </ul>"},{"location":"Tareas/tarea7/#3-conceptos-clave","title":"3) Conceptos clave","text":"<ul> <li>PWM (Modulaci\u00f3n por Ancho de Pulso): controla la tensi\u00f3n media aplicada al motor.  </li> <li>Frecuencia PWM: se usa 2 kHz. Para evitar zumbido audible</li> <li>Duty predefinido: </li> <li>Baja \u2248 30%, Media \u2248 60%, Alta \u2248 90%.</li> </ul>"},{"location":"Tareas/tarea7/#4-codigo","title":"4) C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n\n#define MOTOR_PWM_PIN   0   // salida PWM al driver (IN1)\n#define BTN_UP          1   // subir velocidad\n#define BTN_DOWN        2   // bajar velocidad\n#define MOTOR_DIR_PIN   3   // direcci\u00f3n (IN2) fija = 1\n\n//  Configuraci\u00f3n PWM \n#define F_PWM_HZ 2000       // 2 kHz \n#define TOP      1023       // 10 bits de resoluci\u00f3n (0..1023)\n#define DEBOUNCE_MS 150\n\nint main(void) {\n    stdio_init_all();\n\n    // PWM en pin MOTOR_PWM_PIN\n    gpio_set_function(MOTOR_PWM_PIN, GPIO_FUNC_PWM);\n\n    // Direcci\u00f3n fija a 1 (un solo sentido)\n    gpio_init(MOTOR_DIR_PIN);\n    gpio_set_dir(MOTOR_DIR_PIN, GPIO_OUT);\n    gpio_put(MOTOR_DIR_PIN, 1);\n\n    // Botones con pull-up (activo-bajo)\n    gpio_init(BTN_UP);    gpio_set_dir(BTN_UP, GPIO_IN);    gpio_pull_up(BTN_UP);\n    gpio_init(BTN_DOWN);  gpio_set_dir(BTN_DOWN, GPIO_IN);  gpio_pull_up(BTN_DOWN);\n\n    // Configurar hardware PWM\n    uint slice = pwm_gpio_to_slice_num(MOTOR_PWM_PIN);\n    uint chan  = pwm_gpio_to_channel(MOTOR_PWM_PIN);\n\n    const float f_clk = 125000000.0f; // 125 MHz\n    const float clkdiv = f_clk / (F_PWM_HZ * (TOP + 1));\n    pwm_set_clkdiv(slice, clkdiv);\n    pwm_set_wrap(slice, TOP);\n\n    const uint16_t duty_levels[3] = {\n        (uint16_t)(0.30f * TOP),  // Baja  \n        (uint16_t)(0.60f * TOP),  // Media \n        (uint16_t)(0.90f * TOP)   // Alta  \n    };\n    int speed_level = 0;\n\n    // Iniciar PWM con velocidad \"Baja\"\n    pwm_set_chan_level(slice, chan, duty_levels[speed_level]);\n    pwm_set_enabled(slice, true);\n\n    while (true) {\n        // BTN_UP: siguiente velocidad\n        if (!gpio_get(BTN_UP)) {\n            if (speed_level &lt; 2) speed_level++;\n            pwm_set_chan_level(slice, chan, duty_levels[speed_level]);\n            sleep_ms(DEBOUNCE_MS);\n            // Espera a soltar para evitar autorepetici\u00f3n r\u00e1pida\n            while (!gpio_get(BTN_UP)) tight_loop_contents();\n        }\n\n        // BTN_DOWN: velocidad previa\n        if (!gpio_get(BTN_DOWN)) {\n            if (speed_level &gt; 0) speed_level--;\n            pwm_set_chan_level(slice, chan, duty_levels[speed_level]);\n            sleep_ms(DEBOUNCE_MS);\n            while (!gpio_get(BTN_DOWN)) tight_loop_contents();\n        }\n    }\n}\n</code></pre>"},{"location":"Tareas/tarea7/#5-video-de-demostracion","title":"5) Video de demostracion","text":""},{"location":"Tareas/tarea7/#video","title":"video","text":""},{"location":"Tareas/tarea7/#6-esquematico-de-conexion","title":"6) Esquem\u00e1tico de conexi\u00f3n","text":"<p> Figura 1.</p>"},{"location":"Tareas/tarea7/#7-resultados-y-conclusiones","title":"7) Resultados y conclusiones","text":"<ul> <li> <p>Con 30/60/90% se observan claramente tres reg\u00edmenes de velocidad.</p> </li> <li> <p>Antirrebote bloqueante (150 ms).</p> </li> <li> <p>Usar driver dedicado y GND com\u00fan garantiza estabilidad y protege al microcontrolador.</p> </li> </ul>"},{"location":"Tareas/tarea7/#tarea-72-control-de-frecuencia-cancion-con-buzzer","title":"\ud83c\udfb5 Tarea 7.2 \u2014 Control de Frecuencia: Canci\u00f3n con Buzzer","text":""},{"location":"Tareas/tarea7/#1-resumen_1","title":"1) Resumen","text":"<ul> <li>Entregable: Programar un buzzer piezoel\u00e9ctrico para reproducir una melod\u00eda reconocible (intro de Pac-Man).  </li> <li>T\u00e9cnica: Variar la frecuencia del PWM para cada nota; duty = 50%.  </li> <li>Documentar: Tabla con notas/frecuencias/duraci\u00f3n y evidencia (audio/video).  </li> <li>Recomendaci\u00f3n: Los buzzer piezo suenan mejor ~532 Hz\u20134 kHz. Se usan notas en una octava que cae en ese rango.</li> </ul>"},{"location":"Tareas/tarea7/#2-codigo","title":"2) C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n#define BUZZER_PIN 0\n\n#define TOP 1023        // Resoluci\u00f3n (10 bits)\n#define TEMPO 190       // Tempo r\u00e1pido\n\n// Duraciones de nota\n#define NEGRA        (60000 / TEMPO)\n#define CORCHEA      (NEGRA / 2)\n#define SEMICORCHEA  (NEGRA / 4)\n\nint main() {\n    stdio_init_all();\n    gpio_set_function(BUZZER_PIN, GPIO_FUNC_PWM);\n\n    uint slice = pwm_gpio_to_slice_num(BUZZER_PIN);\n    uint chan  = pwm_gpio_to_channel(BUZZER_PIN);\n\n    pwm_set_wrap(slice, TOP);\n    pwm_set_chan_level(slice, chan, 0);   // empezar en silencio\n    pwm_set_enabled(slice, true);\n\n    // Pac-Man (intro + intermisi\u00f3n)\n    const float frecuencias[] = {\n        // Intro\n        987.77, 1479.98, 1244.51, 987.77, 1479.98, 1244.51, 0,\n        1046.50, 1567.98, 1318.51, 1046.50, 1567.98, 1318.51, 0,\n        987.77, 880.00, 783.99, 698.46, 622.25, 587.33, 0,\n        // Intermisi\u00f3n\n        783.99, 0, 880.00, 0, 987.77, 0, 783.99,\n        987.77, 0, 1046.50, 0, 1174.66, 0, 987.77,\n        1174.66, 0, 1244.51, 0, 1318.51, 0, 1174.66\n    };\n\n    const int duraciones[] = {\n        // Intro\n        CORCHEA, CORCHEA, CORCHEA, CORCHEA, CORCHEA, CORCHEA, CORCHEA,\n        CORCHEA, CORCHEA, CORCHEA, CORCHEA, CORCHEA, CORCHEA, CORCHEA,\n        SEMICORCHEA, SEMICORCHEA, SEMICORCHEA, SEMICORCHEA, SEMICORCHEA, NEGRA, NEGRA,\n        // Intermisi\u00f3n\n        CORCHEA, SEMICORCHEA, CORCHEA, SEMICORCHEA, CORCHEA, SEMICORCHEA, NEGRA,\n        CORCHEA, SEMICORCHEA, CORCHEA, SEMICORCHEA, CORCHEA, SEMICORCHEA, NEGRA,\n        CORCHEA, SEMICORCHEA, CORCHEA, SEMICORCHEA, CORCHEA, SEMICORCHEA, NEGRA\n    };\n\n    const int num_notas = (int)(sizeof(frecuencias) / sizeof(frecuencias[0]));\n\n    while (true) {\n        for (int i = 0; i &lt; num_notas; i++) {\n            if (frecuencias[i] &gt; 0.0f) {\n                // Para RP2350 el sysclk t\u00edpico es 150 MHz; si usas RP2040 usa 125 MHz\n                const float f_clk = 150000000.0f;\n                const float div = f_clk / (frecuencias[i] * (TOP + 1));\n                pwm_set_clkdiv(slice, div);\n                pwm_set_chan_level(slice, chan, TOP / 2); // 50% duty\n            } else {\n                // silencio (pausa)\n                pwm_set_chan_level(slice, chan, 0);\n            }\n            sleep_ms(duraciones[i]);\n        }\n        // Pausa entre repeticiones\n        pwm_set_chan_level(slice, chan, 0);\n        sleep_ms(2000);\n    }\n}\n</code></pre>"},{"location":"Tareas/tarea7/#3-tabla-de-notas-usadas-referencia","title":"3) Tabla de notas usadas (referencia)","text":"Nota (aprox) Frec. (Hz) Comentario B5 987.77 Inicio caracter\u00edstico F\u266f6 1479.98 Agudo brillante D\u266f6 / E\u266d6 1244.51 C6 1046.50 G6 1567.98 E6 1318.51 A5 880.00 G5 783.99 F5 698.46 D\u266f5 / E\u266d5 622.25 D5 587.33 D6 1174.66 <p>Tip: si escuchas distorsi\u00f3n, sube la frecuencia PWM manteniendo el duty 50%.</p>"},{"location":"Tareas/tarea7/#4-evidencias","title":"4) Evidencias","text":""},{"location":"Tareas/tarea7/#video-audio","title":"Video / Audio","text":""},{"location":"Tareas/tarea7/#5-esquematico-de-conexion","title":"5) Esquem\u00e1tico de conexi\u00f3n","text":"<p> Figura 2.</p>"},{"location":"Tareas/tarea7/#6-conclusiones-tarea-72","title":"6) Conclusiones (Tarea 7.2)","text":"<ul> <li>La melod\u00eda se logra variando la frecuencia del PWM con duty fijo (50%).  </li> <li>Mantener el rango ~532 Hz\u20134 kHz asegura buena respuesta del buzzer piezo.  </li> <li>Ajustar clkdiv en tiempo real permite notas afinadas sin bloquear otros procesos.</li> </ul>"},{"location":"Tareas/tarea7/#tarea-73-generacion-de-senales-senoidal-de-60-hz-con-pwm-filtro-rc","title":"\ud83d\udee0\ufe0f Tarea 7.3 \u2014 Generaci\u00f3n de Se\u00f1ales: Senoidal de 60 Hz con PWM + Filtro RC","text":""},{"location":"Tareas/tarea7/#1-resumen_2","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Se\u00f1al senoidal con PWM y filtrado RC  </li> <li>Autor: Carlos Ernesto Camacho Gonz\u00e1lez  </li> <li>Curso / Asignatura: Sistemas Embebidos  </li> <li>Fecha: 16/09/2025  </li> <li>Descripci\u00f3n breve: </li> <li>Generar una se\u00f1al sinusoidal de 60 Hz aproximada mediante PWM variando el duty cycle con una tabla seno.  </li> <li>Filtrar la se\u00f1al usando un filtro RC pasabajos para obtener una forma senoidal limpia en el osciloscopio.  </li> <li>Documentar capturas de PWM sin filtrar y se\u00f1al filtrada.</li> </ul>"},{"location":"Tareas/tarea7/#2-objetivos_1","title":"2) Objetivos","text":"<ul> <li>Implementar una tabla seno para modular el duty cycle del PWM.  </li> <li>Usar un filtro RC que aten\u00fae las componentes de alta frecuencia y deje pasar los 60 Hz.  </li> <li>Verificar la se\u00f1al en osciloscopio antes y despu\u00e9s del filtro.</li> </ul>"},{"location":"Tareas/tarea7/#3-conceptos-clave_1","title":"3) Conceptos clave","text":""},{"location":"Tareas/tarea7/#senal-senoidal-con-pwm","title":"Se\u00f1al senoidal con PWM","text":"<p>El microcontrolador genera una onda PWM cuyo duty cycle sigue la forma de una tabla seno. Tras el filtrado RC, se obtiene una onda anal\u00f3gica.</p>"},{"location":"Tareas/tarea7/#4-codigo_1","title":"4) C\u00f3digo","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n#define SENAL 0          // Pin GPIO de salida\n#define TOP 1023         // Resoluci\u00f3n del PWM (10 bits)\n#define FREQ 60          // Frecuencia de la se\u00f1al senoidal deseada (Hz)\n#define TAMANO_SENO 100  // N\u00famero de puntos en la tabla seno\n\n// Tabla seno (se llenar\u00e1 en tiempo de ejecuci\u00f3n)\nuint16_t TABLA_SENO[TAMANO_SENO];\n\nint main() {\n    stdio_init_all();\n\n    // Llenar tabla seno con valores escalados a [0, TOP]\n    for (uint8_t i = 0; i &lt; TAMANO_SENO; i++) {\n        double RAD = (2 * M_PI * i) / TAMANO_SENO;\n        double VAL = (sin(RAD) + 1.0) / 2.0;  // normalizada a 0\u20131\n        TABLA_SENO[i] = (uint16_t)(VAL * TOP);\n    }\n\n    // Configurar pin PWM\n    gpio_set_function(SENAL, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(SENAL);\n    uint chan = pwm_gpio_to_channel(SENAL);\n\n    pwm_set_wrap(slice, TOP);\n    pwm_set_chan_level(slice, chan, 0);\n    pwm_set_enabled(slice, true);\n\n    // Calcular frecuencia de actualizaci\u00f3n de la LUT\n    double RATE = FREQ * TAMANO_SENO;      // actualizaciones/segundo\n    uint32_t delay_us = 1000000.0 / RATE;  // periodo en \u00b5s\n\n    int INDEX = 0;\n    while (true) {\n        pwm_set_chan_level(slice, chan, TABLA_SENO[INDEX]);\n\n        INDEX++;\n        if (INDEX &gt;= TAMANO_SENO) INDEX = 0;\n\n        sleep_us(delay_us);  // Ajusta la frecuencia\n    }\n}\n</code></pre>"},{"location":"Tareas/tarea7/#5-esquematico-de-conexion_1","title":"5) Esquem\u00e1tico de conexi\u00f3n","text":"<p> Figura 3.</p>"},{"location":"Tareas/tarea7/#6-evidencias","title":"6) Evidencias","text":""},{"location":"Tareas/tarea7/#osciloscopio","title":"Osciloscopio","text":"<ul> <li>Antes del filtro (PWM): se\u00f1al rectangular con duty variable.  </li> <li>Despu\u00e9s del filtro RC: onda senoidal de 60 Hz m\u00e1s limpia.  </li> </ul> <p> *Figura 4. Se\u00f1al PWM *  </p> <p> Figura 5. Se\u00f1al senoidal tras el filtro RC. </p>"},{"location":"Tareas/tarea7/#7-resultados-y-conclusiones_1","title":"7) Resultados y conclusiones","text":"<ul> <li>El PWM con duty modulado por tabla seno reproduce correctamente la forma senoidal.  </li> <li>El filtro RC aten\u00faa los arm\u00f3nicos de alta frecuencia y deja pasar los 60 Hz.  </li> <li>Ajustar R y C permite modificar la frecuencia de corte para un mejor compromiso entre limpieza de se\u00f1al y amplitud.  </li> <li>Se logr\u00f3 una se\u00f1al anal\u00f3gica senoidal a partir de un pin digital del microcontrolador.</li> </ul>"},{"location":"Tareas/tarea8/","title":"\ud83d\udcd8 Tarea 8 \u2014 UART","text":"<p>En esta pr\u00e1ctica trabajamos con la UART del Raspberry Pi Pico 2 para enviar y recibir comandos de texto que controlan un LED. Se abordan dos escenarios: 1) Un bot\u00f3n f\u00edsico genera mensajes \u201cLED ON / LED OFF\u201d por UART. 2) Una terminal serial en la PC env\u00eda esos mismos comandos al microcontrolador.</p>"},{"location":"Tareas/tarea8/#1-boton-que-manda-led-on-led-off-por-uart","title":"1) Bot\u00f3n que manda \u201cLED ON / LED OFF\u201d por UART","text":""},{"location":"Tareas/tarea8/#que-hace","title":"\u00bfQu\u00e9 hace?","text":"<p>Al pulsar el bot\u00f3n, el microcontrolador alterna el estado del LED (enciende/apaga) y env\u00eda por UART.</p> <p>Este patr\u00f3n permite probar la transmisi\u00f3n UART.</p>"},{"location":"Tareas/tarea8/#como-funciona","title":"\u00bfC\u00f3mo funciona?","text":"<ul> <li>Configuramos la UART0 con un baud rate t\u00edpico.  </li> <li>El bot\u00f3n se conecta en modo pull-up: al presionarlo, el pin lee 0 (activo).  </li> <li>Detectamos el flanco de bajada para evitar m\u00faltiples toggles.</li> <li>Al cambiar el estado del LED, mandamos el texto por UART.</li> </ul>"},{"location":"Tareas/tarea8/#codigo","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n\n#define UART_ID uart0\n#define BAUD_RATE 9600\n\n#define UART_TX_PIN 0\n#define UART_RX_PIN 1\n\n#define LED_PIN 15\n#define BUTTON_PIN 16\n\nint main() {\n    stdio_init_all();\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n\n    gpio_init(BUTTON_PIN);\n    gpio_set_dir(BUTTON_PIN, GPIO_IN);\n    gpio_pull_up(BUTTON_PIN);\n\n    bool last_button_state = true;\n    bool led_state = false;\n\n    while (true) {\n        bool button_state = gpio_get(BUTTON_PIN);\n\n        // Si se detecta una pulsaci\u00f3n (de HIGH a LOW)\n        if (last_button_state &amp;&amp; !button_state) {\n            uart_putc(UART_ID, 'T'); // Enviamos el car\u00e1cter 'T' al otro Pico\n            sleep_ms(200); // anti rebote\n        }\n        last_button_state = button_state;\n\n        // Si se recibe un byte por UART\n        if (uart_is_readable(UART_ID)) {\n            char c = uart_getc(UART_ID);\n            if (c == 'T') {\n                led_state = !led_state; // Cambiar estado del LED\n                gpio_put(LED_PIN, led_state);\n            }\n        }\n\n        sleep_ms(10);\n    }\n}\n</code></pre>"},{"location":"Tareas/tarea8/#esquematico-de-conexion","title":"Esquem\u00e1tico de conexi\u00f3n","text":"<p> Figura 1.</p>"},{"location":"Tareas/tarea8/#video-de-demostracion","title":"Video de demostracion","text":""},{"location":"Tareas/tarea8/#2-terminal-serial-que-controla-el-led-con-led-on-led-off","title":"2) Terminal serial que controla el LED con \u201cLED ON / LED OFF\u201d","text":"<p>Desde una terminal serial en la PC se env\u00edan comandos de texto al microcontrolador por UART. El firmware lee los caracteres, detecta el fin de comando y ejecuta:</p>"},{"location":"Tareas/tarea8/#codigo_1","title":"C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n#define button_pin 16\n#define led_PIN 15\nusing namespace std;\n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n\n    uart_init(UART_ID, BAUD_RATE);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n    gpio_init(button_pin);\n    gpio_set_dir(button_pin, GPIO_IN);\n    gpio_pull_up(button_pin);\n    gpio_init(led_PIN);\n    gpio_set_dir(led_PIN, GPIO_OUT);\n\n    string c = \"\";\n    string p=\"\";\n    while (true){\n\n        int ch = getchar_timeout_us(0);\n        if (ch != PICO_ERROR_TIMEOUT) {\n            printf(\"Eco: %c\\n\", (char)ch);\n            p+= (char)ch;\n            if(ch=='.' || ch=='\\n'){\n                uart_puts(UART_ID, p.c_str());\n                p=\"\";\n            }\n        }\n        int a;\n        if (gpio_get(button_pin) == 0 &amp;&amp; a == 1) {\n            printf(\"Button pressed!\\n\");\n            uart_puts(UART_ID, \"LEDON\\n\");\n            sleep_ms(200); \n        }\n         a= gpio_get(button_pin);\n\n        if (uart_is_readable(uart0)) {\n            char character = uart_getc(uart0);\n            printf(character+\"\\n\");\n            if(character=='\\n' || character=='.'){\n                if (c == \"LEDON\"){\n                    gpio_put(led_PIN, 1);\n                    printf(\"LED is ON\\n\");\n                }\n                else if (c == \"LEDOFF\"){\n                    gpio_put(led_PIN, 0);\n                    printf(\"LED is OFF\\n\");\n                } else if(c==\"Invalid Command\"){\n                    printf(\"Invalid Command\\n\");\n                }\n                else{\n                    uart_puts(UART_ID, \"Invalid Command\\n\");\n                }\n                c = \"\";\n                continue;\n            }\n            else{\n                c += character;\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"Tareas/tarea8/#esquematico-de-conexion_1","title":"Esquem\u00e1tico de conexi\u00f3n","text":"<p> Figura 1.</p>"},{"location":"Tareas/tarea8/#video-de-demostracion_1","title":"Video de demostracion","text":""},{"location":"Tareas/tarea9/","title":"\ud83d\udcd8 Tarea 9 \u2014 ADC y Control con Se\u00f1ales Anal\u00f3gicas","text":""},{"location":"Tareas/tarea9/#tarea-91-adc-luxometro-con-ldr-0100","title":"Tarea 9.1 \u2014 ADC Lux\u00f3metro con LDR (0\u2013100%)","text":""},{"location":"Tareas/tarea9/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del subproyecto: Lux\u00f3metro con LDR y ADC  </li> <li>Autor: Carlos Ernesto Camacho Gonz\u00e1lez  </li> <li>Curso / Asignatura: Sistemas Embebidos I  </li> <li>Fecha: 16/09/2025  </li> <li>Descripci\u00f3n breve: </li> <li>Se usa un LDR (fotoresistencia) en un divisor de voltaje conectado al ADC de la Pico 2.  </li> <li>El microcontrolador lee el valor anal\u00f3gico y lo convierte a un valor de 0 a 100 % de luminosidad.  </li> <li>Se aplica una calibraci\u00f3n sencilla con valores m\u00ednimo y m\u00e1ximo medidos en el laboratorio.</li> </ul>"},{"location":"Tareas/tarea9/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Leer una se\u00f1al anal\u00f3gica usando el ADC de la Raspberry Pi Pico 2.  </li> <li>Entender el uso de un LDR como sensor de luz en un divisor de voltaje.  </li> <li>Mapear la lectura del ADC (0\u20134095) a una escala 0\u2013100 % ajustada al rango real del sensor.  </li> </ul>"},{"location":"Tareas/tarea9/#3-circuito","title":"3) Circuito","text":""},{"location":"Tareas/tarea9/#codigo","title":"C\u00f3digo","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/adc.h\"\n\n// Configurar el canal ADC a usar\n#define ADC_INPUT 0 // canal 0\n\n#define ADC_MIN 850    // valor cuando tapas la LDR\n#define ADC_MAX 3100   // valor con luz m\u00e1xima\n\nint main() {\n    stdio_init_all();\n    adc_init();\n    // Configura el pin GPIO correspondiente como entrada ADC\n    adc_gpio_init(26); // GPIO26 suele mapear a ADC0 en Pico 2\n    // Seleccionar canal\n    adc_select_input(ADC_INPUT);\n\n    while (true) {\n        uint16_t adc = adc_read(); // 12 bits alineados a 0..4095\n\n        if (adc &lt; ADC_MIN) adc = ADC_MIN;\n        if (adc &gt; ADC_MAX) adc = ADC_MAX;\n\n        // Calcular porcentaje de luz 0\u2013100\n        float luz = (adc - ADC_MIN) * 100.0f / (ADC_MAX - ADC_MIN);\n\n        printf(\"ADC: %u\\tLuz: %.1f%%\\n\", adc, luz);\n        sleep_ms(200);\n    }\n}\n</code></pre>"},{"location":"Tareas/tarea9/#4-esquematico-de-conexion","title":"4) Esquem\u00e1tico de conexi\u00f3n","text":"<p> Figura 1.</p>"},{"location":"Tareas/tarea9/#5-video-de-demostracion","title":"5) Video de demostracion","text":""},{"location":"Tareas/tarea9/#tarea-92-servo-con-potenciometro-y-adc","title":"Tarea 9.2 \u2014 Servo con Potenci\u00f3metro y ADC","text":""},{"location":"Tareas/tarea9/#1-resumen_1","title":"1) Resumen","text":"<ul> <li>Autor: Carlos Ernesto Camacho Gonz\u00e1lez  </li> <li>Materia: Sistemas Embebidos I  </li> <li>Fecha: 16/09/2025  </li> <li>Descripci\u00f3n:   Control de un servo motor con un potenci\u00f3metro usando el ADC de la Raspberry Pi Pico 2.   El giro del potenci\u00f3metro controla el \u00e1ngulo del servo entre 0\u00b0 y 180\u00b0.</li> </ul>"},{"location":"Tareas/tarea9/#2-circuito","title":"2) Circuito","text":""},{"location":"Tareas/tarea9/#codigo_1","title":"C\u00f3digo","text":"<pre><code>#include &lt;iostream&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/adc.h\"\n#include \"hardware/pwm.h\"\n\nusing namespace std;\n\n#define SERVO_PIN 0    \n#define POT_PIN 26      \n\nint main() {\n    stdio_init_all();\n\n   //inicializar ADC\n    adc_init();\n    adc_gpio_init(POT_PIN);\n    adc_select_input(0);\n    adc_set_clkdiv(479.0f);          \n    adc_fifo_setup(true, false, 1, false, false);  \n    adc_fifo_drain();                \n    adc_run(true);                    \n\n   //inicializar PWM para el servo\n    gpio_set_function(SERVO_PIN, GPIO_FUNC_PWM);\n    uint slice_num = pwm_gpio_to_slice_num(SERVO_PIN); //aplicar configuracion al slice\n\n    pwm_set_clkdiv(slice_num, 64.0f);\n    pwm_set_wrap(slice_num, 39062);  \n//ajustar frecuencia del pwm\n    pwm_set_enabled(slice_num, true);\n\n    while (true) {\n\n        if (adc_fifo_get_level() &gt; 0) { //para ver si hay algo dentro del fifo\n            uint16_t valor_adc = adc_fifo_get();\n\n\n            float duty = 0.025f + (valor_adc / 4095.0f) * 0.1f;\n\n            pwm_set_gpio_level(SERVO_PIN, duty * 39062);\n\n\n        }\n\n        sleep_ms(20);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"Tareas/tarea9/#3-esquematico-de-conexion","title":"3) Esquem\u00e1tico de conexi\u00f3n","text":"<p> Figura 2.</p>"},{"location":"Tareas/tarea9/#4-video-de-demostracion","title":"4) Video de demostracion","text":""},{"location":"proyecto-ingenieria-iv/","title":"Index","text":""},{"location":"proyecto-ingenieria-iv/ProyectoFinal/","title":"Citizen Quack \u2014 Sistema de monitoreo de calidad del agua (nodo flotante con LoRa)","text":"<p>Proyecto final \u2014 Lanzamiento de producto / Proyecto de Ingenier\u00eda Estado: \u2705 Entrega final documentada (reporte + presentaci\u00f3n)</p>"},{"location":"proyecto-ingenieria-iv/ProyectoFinal/#1-titulo-del-proyecto","title":"1) T\u00edtulo del proyecto","text":"<p>Citizen Quack \u2014 Sistema de monitoreo de calidad del agua Nodo flotante con forma de pato, equipado con sensores y comunicaci\u00f3n LoRa hacia una estaci\u00f3n base.</p>"},{"location":"proyecto-ingenieria-iv/ProyectoFinal/#2-equipo-autores","title":"2) Equipo / Autores","text":"<ul> <li>Carlos Ernesto Camacho Gonz\u00e1lez </li> <li>Danna Paola Garc\u00eda S\u00e1nchez </li> <li>Sebasti\u00e1n Rodas Apango</li> </ul>"},{"location":"proyecto-ingenieria-iv/ProyectoFinal/#3-linea-de-tiempo-y-contexto","title":"3) L\u00ednea de tiempo y contexto","text":"<ul> <li>Inicio del proyecto: 01/09/2025 (semana 1)  </li> <li>Estado actual: Entrega final disponible (reporte PDF + presentaci\u00f3n).  </li> <li>Curso / contexto: Proyecto de Ingenier\u00eda / Lanzamiento de producto.</li> </ul>"},{"location":"proyecto-ingenieria-iv/ProyectoFinal/#4-resumen-ejecutivo","title":"4) Resumen ejecutivo","text":"<p>Citizen Quack es un sistema de monitoreo de calidad del agua basado en un nodo flotante con forma de pato que:</p> <ul> <li>Mide par\u00e1metros como:</li> <li>pH  </li> <li>Temperatura  </li> <li>Conductividad el\u00e9ctrica  </li> <li>(Opcional) otros par\u00e1metros seg\u00fan sensores disponibles.</li> <li>Env\u00eda los datos mediante LoRa a una estaci\u00f3n base.</li> <li>Permite visualizar la informaci\u00f3n en un panel / dashboard para an\u00e1lisis.</li> </ul> <p>Objetivo principal: Pasar de muestreos manuales e intermitentes a un monitoreo remoto, m\u00e1s frecuente y escalable en cuerpos de agua (lagos, presas, canales, etc.), para facilitar la detecci\u00f3n temprana de contaminaci\u00f3n y apoyar la toma de decisiones.</p>"},{"location":"proyecto-ingenieria-iv/ProyectoFinal/#5-problema-y-motivacion","title":"5) Problema y motivaci\u00f3n","text":""},{"location":"proyecto-ingenieria-iv/ProyectoFinal/#problema-actual","title":"Problema actual","text":"<p>El monitoreo t\u00edpico de la calidad del agua suele ser:</p> <ul> <li>Manual: personal debe acudir f\u00edsicamente al cuerpo de agua.</li> <li>Intermitente: se realizan pocas mediciones al mes o al a\u00f1o.</li> <li>Dependiente de horarios y disponibilidad de recursos humanos.</li> </ul> <p>Esto genera:</p> <ul> <li>Poca informaci\u00f3n en tiempo real.</li> <li>Dificultad para detectar:</li> <li>Cambios bruscos en par\u00e1metros cr\u00edticos.</li> <li>Eventos de contaminaci\u00f3n (descargas, derrames, etc.).</li> <li>Respuestas tard\u00edas ante problemas ambientales.</li> </ul>"},{"location":"proyecto-ingenieria-iv/ProyectoFinal/#propuesta-de-citizen-quack","title":"Propuesta de Citizen Quack","text":"<p>Citizen Quack plantea:</p> <ul> <li>Un nodo flotante econ\u00f3mico, replicable y escalable.</li> <li>Posibilidad de desplegar varios nodos en un mismo cuerpo de agua.</li> <li>Env\u00edo peri\u00f3dico de datos hacia una base central mediante LoRa.</li> <li>Construcci\u00f3n de series de tiempo para an\u00e1lisis y alertas tempranas.</li> </ul>"},{"location":"proyecto-ingenieria-iv/ProyectoFinal/#6-boceto-y-recursos-visuales","title":"6) Boceto y recursos visuales","text":""},{"location":"proyecto-ingenieria-iv/ProyectoFinal/#boceto-del-dispositivo-diseno-inicial","title":"Boceto del dispositivo (dise\u00f1o inicial)","text":"<p>Archivo: <code>docs/img/citizen-quack-boceto.png</code>.</p>"},{"location":"proyecto-ingenieria-iv/ProyectoFinal/#version-final-del-pato-impresion-3d","title":"Versi\u00f3n final del pato (impresi\u00f3n 3D)","text":"<p>Foto del pato impreso con la electr\u00f3nica montada.</p>"},{"location":"proyecto-ingenieria-iv/ProyectoFinal/#dashboard-aplicacion","title":"Dashboard / aplicaci\u00f3n","text":"<p>Captura del dashboard de pH en tiempo real (lecturas recibidas v\u00eda MQTT).</p>"},{"location":"proyecto-ingenieria-iv/ProyectoFinal/#7-presentacion-del-proyecto","title":"7) Presentaci\u00f3n del proyecto","text":"<ul> <li>Presentaci\u00f3n interactiva (Canva): Ver presentaci\u00f3n en Canva</li> </ul>"},{"location":"proyecto-ingenieria-iv/ProyectoFinal/#presentacion-pdf-exportado-de-canva-embebido","title":"Presentaci\u00f3n (PDF exportado de Canva \u2014 embebido)","text":"<p>Si no se muestra correctamente, puedes descargarla aqu\u00ed: \ud83d\udcca Descargar presentaci\u00f3n en PDF</p>"},{"location":"proyecto-ingenieria-iv/ProyectoFinal/#8-reporte-final-del-proyecto","title":"8) Reporte final del proyecto","text":""},{"location":"proyecto-ingenieria-iv/ProyectoFinal/#reporte-final-pdf-embebido","title":"Reporte final (PDF embebido)","text":"<p>Si el visor no se carga correctamente, tambi\u00e9n puedes descargar el archivo aqu\u00ed: \ud83d\udcc4 Descargar reporte final</p>"},{"location":"proyecto-ingenieria-iv/semana-1/","title":"\ud83d\udc24 Citizen Quack \u2014 Soluci\u00f3n de calidad del agua","text":"<p>Citizen Quack con sensores de calidad del agua y env\u00edo LoRa a un panel de datos.</p>"},{"location":"proyecto-ingenieria-iv/semana-1/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): Carlos Ernesto Camacho Gonz\u00e1lez, Danna Paola Garc\u00eda Sanchez, Sebastian Rodas Apango </li> <li>Curso / Asignatura: Proyecto de Ingenier\u00eda IV </li> <li>Fecha: 01/09/2025  </li> <li>Descripci\u00f3n breve: Se propone un nodo flotante con forma de pato que mide pH, temperatura, conductividad, etc en cuerpos de agua. Los datos se env\u00edan por LoRa a una estaci\u00f3n base y se visualizan en un panel de datos.</li> </ul>"},{"location":"proyecto-ingenieria-iv/semana-1/#2-problema-y-motivacion","title":"2) Problema y motivaci\u00f3n","text":"<ul> <li>Monitoreo de calidad del agua intermitente o manual.  </li> </ul>"},{"location":"proyecto-ingenieria-iv/semana-1/#3-boceto","title":"3) Boceto","text":""},{"location":"proyecto-ingenieria-iv/semana-1/#4-pdf-de-syllabus","title":"4) PDF de Syllabus","text":""},{"location":"proyecto-ingenieria-iv/semana-3/","title":"\ud83d\udc24 Semana 3 \u2014 Presentaci\u00f3n de avance (Citizen Quack)","text":""},{"location":"proyecto-ingenieria-iv/semana-3/#1-objetivo-de-la-semana","title":"1) Objetivo de la semana","text":"<ul> <li>Presentar el estado del proyecto (boceto, sensores, TRL, riesgos y plan).</li> </ul>"},{"location":"proyecto-ingenieria-iv/semana-3/#2-evidencia-presentacion-pdf","title":"2) Evidencia \u2014 Presentaci\u00f3n (PDF)","text":""},{"location":"proyecto-ingenieria-iv/semana-4/","title":"\ud83d\udc24 Semana 4 \u2014 Diagrama de Gantt (Citizen Quack)","text":""},{"location":"proyecto-ingenieria-iv/semana-4/#1-objetivo-de-la-semana","title":"1) Objetivo de la semana","text":"<ul> <li>Publicar y mantener el plan de trabajo (tareas, responsables y fechas) en un diagrama de Gantt actualizado.</li> </ul>"},{"location":"proyecto-ingenieria-iv/semana-4/#2-enlace-directo-al-gantt","title":"2) Enlace directo al Gantt","text":"<p>\ud83d\udd17 Abrir Gantt en Repsona</p>"},{"location":"proyecto-ingenieria-iv/semana-4/#3-gantt-embebido-vista-dentro-de-la-pagina","title":"3) Gantt embebido (vista dentro de la p\u00e1gina)","text":""},{"location":"proyecto-ingenieria-iv/semana-5/","title":"\ud83d\udc24 Semana 5 \u2014 Marco \u201cReal-Ganar-Vale la pena\u201d aplicado al proyecto Citizen Quack","text":""},{"location":"proyecto-ingenieria-iv/semana-5/#1-objetivo-de-la-semana","title":"1) Objetivo de la semana","text":"<ul> <li>Analizar el proyecto Citizen Quack bajo el marco \u201cReal-Ganar-Vale la pena\u201d.</li> </ul>"},{"location":"proyecto-ingenieria-iv/semana-5/#2-resumen-del-documento","title":"2) Resumen del documento","text":"<p>El an\u00e1lisis detalla: - Real: evidencia del problema y el impacto ambiental y sanitario. - Ganar: ver si es viable para medici\u00f3n de calidad del agua. - Vale la pena: beneficios ambientales, sociales y econ\u00f3micos al implementar Citizen Quack.  </p>"},{"location":"proyecto-ingenieria-iv/semana-5/#3-documento-pdf","title":"3) Documento PDF","text":""},{"location":"proyecto-ingenieria-iv/semana-6/","title":"\ud83d\udc24 Semana 6 \u2014 An\u00e1lisis de modelo de negocio y 5 fuerzas de Porter","text":""},{"location":"proyecto-ingenieria-iv/semana-6/#1-objetivo-de-la-semana","title":"1) Objetivo de la semana","text":"<ul> <li>Definir la propuesta de valor y el modelo de ingresos del proyecto Citizen Quack.</li> <li>Analizar el entorno competitivo mediante el modelo de las 5 fuerzas de Porter.</li> </ul>"},{"location":"proyecto-ingenieria-iv/semana-6/#2-business-model-canvas","title":"2) Business Model Canvas","text":"<p>El modelo de negocio se centra en un dispositivo IoT en forma de pato para monitorear la calidad del agua en tiempo real, orientado a hogares, hoteles y clubes con albercas. Incluye hardware de bajo costo, conectividad LoRa y un modelo de suscripci\u00f3n para alertas avanzadas.</p>"},{"location":"proyecto-ingenieria-iv/semana-6/#3-analisis-de-las-5-fuerzas-de-porter","title":"3) An\u00e1lisis de las 5 Fuerzas de Porter","text":""},{"location":"proyecto-ingenieria-iv/semana-7/","title":"\ud83d\udc24 Semana 7 \u2014 Costo del proyecto Citizen Quack","text":""},{"location":"proyecto-ingenieria-iv/semana-7/#1-objetivo-de-la-semana","title":"1) Objetivo de la semana","text":"<ul> <li>Desglosar los costos de desarrollo del prototipo Citizen Quack.  </li> <li>Identificar los recursos materiales y de tiempo requeridos para alcanzar la siguiente fase del proyecto.</li> </ul>"},{"location":"proyecto-ingenieria-iv/semana-7/#2-descripcion-general","title":"2) Descripci\u00f3n general","text":"<p>El an\u00e1lisis incluye tres bloques principales:</p> <ol> <li>Programaci\u00f3n y comunicaci\u00f3n: integraci\u00f3n de sensores con el microcontrolador, conexi\u00f3n LoRa, desarrollo de base de datos y generaci\u00f3n de alertas.  </li> <li>Dise\u00f1o y fabricaci\u00f3n del PCB: esquem\u00e1tico, trazado, fabricaci\u00f3n, pruebas el\u00e9ctricas y correcciones.  </li> <li>Dise\u00f1o y fabricaci\u00f3n de la carcasa: modelado 3D, impresi\u00f3n 3D, pruebas de flotabilidad y sellado impermeable.</li> </ol>"},{"location":"proyecto-ingenieria-iv/semana-7/#3-documento-pdf","title":"3) Documento PDF","text":""},{"location":"proyecto-ingenieria-iv/semana-8/","title":"\ud83d\udcb0 Costos \u2014 Citizen Quack (Excel)","text":"<p>Aqu\u00ed se presentan los costos generales del proyecto, integrando materiales, componentes, distribuci\u00f3n y operaci\u00f3n (incluido el servidor LoRa).</p>"},{"location":"proyecto-ingenieria-iv/semana-8/#excel","title":"\ud83d\udcc4 Excel","text":"<p>Puedes visitar la hoja de c\u00e1lculo aqu\u00ed:</p> <p>\ud83d\udd17 Abrir hoja de costos en OneDrive</p>"},{"location":"proyecto-ingenieria-iv/trello/","title":"\ud83d\udc24 Trello \u2014 Citizen Quack","text":""},{"location":"proyecto-ingenieria-iv/trello/#descripcion-general","title":"Descripci\u00f3n general","text":"<p>Este tablero de Trello se utiliza para organizar el flujo de trabajo del proyecto Citizen Quack.  </p>"},{"location":"proyecto-ingenieria-iv/trello/#acceso-al-tablero","title":"Acceso al tablero","text":"<p>\ud83d\udc49 Abrir tablero en Trello</p>"}]}